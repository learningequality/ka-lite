<!DOCTYPE html>
<html data-require="math graphie graphie-geometry interactive constructions kmatrix">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<title>Construcciones con regla y compás</title>
<script src="../khan-exercise.js"></script><script>
        var applyRefFrame = function(coord, rot) {
            var rotCoord = [];
            rotCoord[0] = Math.cos(rot) * coord[0] - Math.sin(rot) * coord[1];
            rotCoord[1] = Math.sin(rot) * coord[0] + Math.cos(rot) * coord[1];

            return rotCoord;
        };
    </script>
</head>
<body>
    <div class="exercise">
    <div class="vars">
        <var id="ROT">(random() &lt; 0.5 ? randRange(10, 80): randRange(100, 170)) * PI / 180</var>
        <var id="SLOPE">tan(ROT)</var>
        <var id="HGRAPH">0</var>
    </div>

    <div class="problems">
        <div id="perpendicular">
            <div class="problem">
                <form>
                    <input onclick="javascript: KhanUtil.construction.addCompass();" type="button" value="Utilizar el compás"><input onclick="javascript: KhanUtil.construction.addStraightedge();" type="button" value="Utilizar la regla"><input onclick="javascript: KhanUtil.construction.removeAllTools();" type="button" value="Borrar">
</form>
                <p class="question">Construir una línea perpendicular a la línea dada.</p>
                <div class="graphie" id="construction">init({range:[[-5,5],[-5,5]],scale:50}),addMouseLayer(),addConstruction("construction");var a=applyRefFrame([4,0],ROT),b=applyRefFrame([-4,0],ROT);addDummyStraightedge(a,b)</div>
            </div>
            <div class="solution" data-type="custom">
                <div class="instruction">Usa el compás y la regla para construir una línea perpendicular a la línea dada.</div>
                <div class="guess">getToolProperties(construction)</div>
                <div class="validator-function">if(0===guess.length)return"";if(perp=null,_.each(guess,function(e){null!=e.first&amp;&amp;(ang=atan2(e.second.coord[1]-e.first.coord[1],e.second.coord[0]-e.first.coord[0]),deg=180*ang/PI,origDeg=180*ROT/PI,(abs(deg-origDeg+90)&lt;7||abs(deg-origDeg-90)&lt;7)&amp;&amp;(perp=e))}),null==perp)return!1;if(comps=_.filter(guess,function(e){return null!=e.center}),comps.length&lt;2)return!1;if(onLine=[],_.each(comps,function(e){_.each(comps,function(r){thisSlope=(e.center.coord[1]-r.center.coord[1])/(e.center.coord[0]-r.center.coord[0]),thisYInt=e.center.coord[1]-thisSlope*e.center.coord[0],abs(thisSlope-SLOPE)&lt;.5&amp;&amp;abs(thisYInt)&lt;.1&amp;&amp;(onLine=[e,r])})}),onLine.length&lt;2)return!1;var e=onLine[0].center.coord[0],r=onLine[0].center.coord[1],a=onLine[1].center.coord[0],t=onLine[1].center.coord[1],s=onLine[0].radius,n=onLine[1].radius,i=a-e,o=t-r,l=sqrt(pow(i,2)+pow(o,2)),p=(pow(l,2)+pow(s,2)-pow(n,2))/(2*l),c=e+i*p/l+o/l*sqrt(pow(s,2)-pow(p,2)),h=r+o*p/l-i/l*sqrt(pow(s,2)-pow(p,2));return interYInt=h+c*(1/SLOPE),perpYInt=perp.first.coord[1]+perp.first.coord[0]*(1/SLOPE),abs(interYInt-perpYInt)&lt;1</div>
                <div class="show-guess">showConstructionGuess(guess)</div>
            </div>
            <div class="hints">
                <div>
                    <div class="graphie" data-update="construction">graph.perp=raphael.set(),graph.perp.push(line(applyRefFrame([0,10],ROT),applyRefFrame([0,-10],ROT),{strokeWidth:1,stroke:BLUE})).toBack()</div>
                    <p>Podríamos dibujar una línea y <em>tratar</em> de hacerla perpendicular, pero entonces <strong>no tenemos garantía</strong> que será perfectamente perpendicular.</p>
                    <p>¿Cómo puedes garantizar que una línea es perpendicular?</p>
                </div>
                <div>
                    <div class="graphie" data-update="construction">graph.perpPoints=raphael.set(),graph.hintLines=raphael.set(),style({fill:BLUE,stroke:null},function(){graph.perpPoints.push(circle(applyRefFrame([0,-1],ROT),.08)),graph.perpPoints.push(circle(applyRefFrame([0,1],ROT),.08))}),graph.perp.push(drawHintLine(applyRefFrame([0,0],ROT),applyRefFrame([0,1],ROT),1)),graph.perp.push(drawHintLine(applyRefFrame([0,0],ROT),applyRefFrame([0,-1],ROT),1)),graph.hintLines.push(drawHintLine(applyRefFrame([0,-1],ROT),applyRefFrame([1,0],ROT),2)),graph.hintLines.push(drawHintLine(applyRefFrame([0,1],ROT),applyRefFrame([1,0],ROT),2)),graph.hintLines.push(drawHintLine(applyRefFrame([0,-1],ROT),applyRefFrame([-2,0],ROT),3)),graph.hintLines.push(drawHintLine(applyRefFrame([0,1],ROT),applyRefFrame([-2,0],ROT),3)),graph.perp.toBack(),graph.hintLines.toBack(),graph.perpPoints.toBack()</div>
                    <p>Si elegimos <span class="hint_blue"> dos puntos</span> en la línea perpendicular que están a la misma distancia de la intersección, también estarán a la misma distancia desde cualquier punto sobre la línea con la que empezamos.</p>
                </div>
                <div>
                    <div class="graphie" data-update="construction">graph.perp.remove()</div>
                    <p>Si todavia no tenemos una línea perpendicular, ¿hay otra forma de encontrar los puntos azules?</p>
                </div>
                <div>
                    <div class="graphie" data-update="construction">circle(applyRefFrame([1,0],ROT),.08,{fill:GRAY,stroke:null}),circle(applyRefFrame([1,0],ROT),eDist(applyRefFrame([0,-1],ROT),applyRefFrame([1,0],ROT)),{stroke:GRAY,strokeWidth:1,fill:"none",strokeDasharray:"- "})</div>
                    <p>Si utilizamos el compás para poner un círculo en algún lugar sobre la línea, el círculo incluirá todos los puntos que están a la misma distancia de ese punto, incluyendo los dos puntos azules.</p>
                </div>
                <div>
                    <div class="graphie" data-update="construction">circle(applyRefFrame([-2,0],ROT),.08,{fill:GRAY,stroke:null}),circle(applyRefFrame([-2,0],ROT),eDist(applyRefFrame([0,-1],ROT),applyRefFrame([-2,0],ROT)),{stroke:GRAY,strokeWidth:1,fill:"none",strokeDasharray:"- "})</div>
                    <p>Podemos agregar un segundo círculo en otro lugar en la línea que se cruza con el primer círculo.</p>
                </div>
                <div>
                    <div class="graphie" data-update="construction">graph.hintLines.remove()</div>
                    <p>Los puntos donde se cruzan los dos círculos pueden ser utilizados para dibujar una línea perpendicular.</p>
                </div>
                <div>
                    <div class="graphie" data-update="construction">graph.perpPoints.attr({fill:GRAY}),line(applyRefFrame([0,10],ROT),applyRefFrame([0,-10],ROT),{strokeWidth:1,stroke:GRAY,strokeDasharray:"- "}).toBack()</div>
                    <p>Usa una regla para conectar los dos puntos donde se cruzan los círculos. Esta línea es perpendicular a la línea dada.</p>
                </div>
            </div>
        </div>

        <div id="parallel">
            <div class="vars">
                <var id="DEG">ROT * 180/PI - 180</var>
                <var id="DY">randRange(3, 5) / 2</var>
                <var id="A">applyRefFrame([2, -DY], ROT)</var>
                <var id="B">applyRefFrame([-2, -DY], ROT)</var>
                <var id="P">applyRefFrame([0, DY], ROT)</var>
                <var id="R">1.2</var>
            </div>

            <div class="problem">
                <form>
                    <input onclick="javascript: KhanUtil.construction.addCompass();" type="button" value="Utilizar el compás"><input onclick="javascript: KhanUtil.construction.addStraightedge();" type="button" value="Utilizar la regla"><input onclick="javascript: KhanUtil.construction.removeAllTools();" type="button" value="Borrar">
</form>
                <p class="question">Construye una línea paralela a la línea dada, que pase por <code>P</code>.</p>
                <div class="graphie" id="construction">init({range:[[-5,5],[-5,5]],scale:50}),addMouseLayer(),addConstruction("construction"),addDummyStraightedge(A,B),addDummyPoint(P),label(P,"P",0&gt;SLOPE?"left":"below")</div>
            </div>

            <div class="solution" data-type="custom">
                <div class="instruction">Usa la regla y el compás para construir una línea paralela a la línea que se muestra.</div>
                <div class="guess">getToolProperties(construction)</div>
                <div class="validator-function">if(0===guess.length)return"";var e=_.filter(guess,function(e){return null!=e.first?isPointOnLineSegment([e.first.coord,e.second.coord],P,.1):void 0});if(e.length&lt;2)return!1;var r=null,a=null,t=_.filter(e,function(e){var t=atan2(e.second.coord[1]-e.first.coord[1],e.second.coord[0]-e.first.coord[0]),s=abs(180*abs(t-ROT)/PI-90);return abs(s-90)&gt;5?(r=t,a=(90-s)*PI/180,!1):!0});if(0===t.length)return!1;var s=findCompass(guess,{cx:P[0],cy:P[1]});if(1!==s.length)return!1;var n=s[0].radius,i=[P[0]-n*cos(r),P[1]-n*sin(r)],o=[P[0]+n*cos(r),P[1]+n*sin(r)],l=2*n*sin(a/2),p=findCompass(guess,{cx:i[0],cy:i[1],radius:l}),c=findCompass(guess,{cx:o[0],cy:o[1],radius:l});return 1===p.length||1===c.length</div>
                <div class="show-guess">showConstructionGuess(guess)</div>
            </div>

            <div class="hints">
                <div>
                    <div class="graphie" data-update="construction">var dx=10*cos(ROT),dy=10*sin(ROT);graph.parallel=raphael.set(),graph.parallel.push(line([P[0]-dx,P[1]-dy],[P[0]+dx,P[1]+dy],{strokeWidth:1,stroke:BLUE})).toBack()</div>
                    <p>Podríamos dibujar una recta en <code>P</code> y <em>tratar de</em> hacerla paralela, pero entonces <strong>no tenemos ninguna garantía </strong> de que es perfectamente paralela.</p>
                </div>

                <div>
                    <div class="graphie" data-update="construction">var d=applyRefFrame([-1,DY],ROT);line([A[0]+10*d[0],A[1]+10*d[1]],[A[0]-10*d[0],A[1]-10*d[1]],{strokeWidth:1,stroke:BLUE}).toBack(),graph.angleAP=atan2(P[1]-A[1],P[0]-A[0]),arc(A,.5,180*graph.angleAP/PI,DEG,!1,{strokeWidth:1,stroke:BLUE}).toBack(),graph.parallel.push(arc(P,.5,180*graph.angleAP/PI,DEG,!1,{strokeWidth:1,stroke:BLUE})),addDummyPoint(A),label(A,"A",0&gt;SLOPE?"above":"below")</div>
                    <p>Si teníamos una línea paralela y trazamos una línea desde un punto <code>A</code> en la línea determinada, a través de <code>P</code>, entonces el ángulo en <code>A</code> debe ser igual al ángulo en <code>P</code>.</p>
                    <p>Por lo tanto, si copiamos el ángulo en <code>A</code> al punto <code>P</code>, seremos capaces de construir líneas paralelas.</p>
                </div>

                <div>
                    <div class="graphie" data-update="construction">var d1=applyRefFrame([-R,0],ROT),d2=applyRefFrame([R,0],graph.angleAP);graph.p1=[A[0]+d1[0],A[1]+d1[1]],graph.p2=[A[0]+d2[0],A[1]+d2[1]],graph.p3=[P[0]+d1[0],P[1]+d1[1]],graph.p4=[P[0]+d2[0],P[1]+d2[1]],circle(graph.p1,.08,{stroke:null,fill:BLUE}),circle(graph.p2,.08,{stroke:null,fill:BLUE}),graph.hintPoint1=circle(graph.p3,.08,{stroke:null,fill:BLUE}),graph.hintPoint2=circle(graph.p4,.08,{stroke:null,fill:BLUE}),drawHintLine(A,graph.p1,2).toBack(),drawHintLine(A,graph.p2,2).toBack(),graph.parallel.push(drawHintLine(graph.p1,graph.p2,1)),graph.parallel.push(drawHintLine(graph.p3,graph.p4,1)),graph.parallel.push(drawHintLine(P,graph.p3,2)),graph.parallel.push(drawHintLine(P,graph.p4,2)),graph.parallel.toBack()</div>
                    <p>Si construimos <span class="hint_blue">un triángulo</span> con un vértice en el punto <code>A</code>, y después construimos un triángulo con las mismas longitudes en el punto <code>P</code>, los ángulos en <code>A</code> y <code>P</code> serán los mismos.</p>
                </div>

                <div>
                    <div class="graphie" data-update="construction">graph.parallel.remove(),graph.hintPoint1.remove(),graph.hintPoint2.remove(),circle(A,.08,{stroke:null,fill:GRAY}),circle(A,R,{fill:null,stroke:GRAY,strokeWidth:1,strokeDasharray:"- "})</div>
                    <p>Podemos utilizar un compás centrado en <code>A</code> para encontrar todos los punto que tengan una distancia determinada desde <code>A</code>.</p>
                </div>

                <div>
                    <div class="graphie" data-update="construction">var compassVertex=circle(A,.08,{stroke:null,fill:GRAY}),compassCircumference=circle(A,R,{fill:null,stroke:GRAY,strokeWidth:1,strokeDasharray:"- "});compassVertex.animate({cx:scalePoint(P)[0],cy:scalePoint(P)[1]},1e3),compassCircumference.animate({cx:scalePoint(P)[0],cy:scalePoint(P)[1]},1e3)</div>
                    <p>Podemos utilizar un compás <strong>con el mismo radio</strong> centrado en <code>P</code> para encontrar todos los puntos que se encuentran a la misma distancia de <code>P</code>. Para asegurarnos de tener el mismo radio, primero ponemos el compás en el punto <code>A</code>, ajustamos el radio para que sean iguales, y luego movemos el compás al punto <code>P</code>.</p>
                </div>

                <div>
                    <div class="graphie" data-update="construction">graph.compassVertex=circle(graph.p2,.08,{stroke:null,fill:GRAY}).toBack(),graph.compassCircumference=circle(graph.p2,eDist(graph.p1,graph.p2),{fill:null,stroke:GRAY,strokeWidth:1,strokeDasharray:"- "})</div>
                    <p>Para encontrar la distancia entre los <span class="hint_blue"> dos puntos equidistantes de <code>A</code></span>, podemos agregar el centro del compás en un punto  y mover el radio hasta que toque el otro punto.</p>
                </div>

                <div>
                    <div class="graphie" data-update="construction">graph.compassVertex.animate({cx:scalePoint(graph.p4)[0],cy:scalePoint(graph.p4)[1]},1e3),graph.compassCircumference.animate({cx:scalePoint(graph.p4)[0],cy:scalePoint(graph.p4)[1]},1e3)</div>
                    <p>Ahora mueve el compás hasta el punto donde el trazo del primer compás intersecta la línea que pasa por <code>P</code>.</p>
                </div>

                <div>
                    <div class="graphie" data-update="construction">drawHintLine(graph.p1,graph.p2,1),drawHintLine(graph.p3,graph.p4,1),drawHintLine(P,graph.p3,2),drawHintLine(P,graph.p4,2),circle(graph.p3,.08,{stroke:null,fill:BLUE}),circle(graph.p4,.08,{stroke:null,fill:BLUE})</div>
                    <p>Ahora podemos usar el punto donde se intersectan los trazos de los dos compases para construir un triángulo con las mismas longitudes laterales que las del triángulo en el punto <code>A</code>.</p>
                </div>

                <div>
                    <div class="graphie" data-update="construction">var dx=10*cos(ROT),dy=10*sin(ROT);line([P[0]+dx,P[1]+dy],[P[0]-dx,P[1]-dy],{strokeWidth:1,stroke:BLUE}).toBack()</div>
                    <p>Finalmente, usa una línea recta para conectar el punto <code>P</code> con la intersección que forman los dos compases. Esta línea será paralela a la línea original.</p>
                </div>
            </div>
        </div>

        <div id="bisector">
            <div class="problem">
                <form>
                    <input onclick="javascript: KhanUtil.construction.addCompass();" type="button" value="Utilizar el compás"><input onclick="javascript: KhanUtil.construction.addStraightedge();" type="button" value="Utilizar la regla"><input onclick="javascript: KhanUtil.construction.removeAllTools();" type="button" value="Borrar">
</form>
                <p class="question">Construye una mediatriz de <code>\overline{AB}</code>.</p>
                <div class="graphie" id="construction">init({range:[[-5,5],[-5,5]],scale:50}),addMouseLayer(),addConstruction("construction");var a=applyRefFrame([1.5,0],ROT),b=applyRefFrame([-1.5,0],ROT);a=[roundToNearest(.01,a[0]),roundToNearest(.01,a[1])],b=[roundToNearest(.01,b[0]),roundToNearest(.01,b[1])],addDummyStraightedge(a,b,!1),addDummyPoint(a),addDummyPoint(b);var offset="above";180*ROT/PI&gt;50&amp;&amp;90&gt;180*ROT/PI&amp;&amp;(offset="left"),130&gt;180*ROT/PI&amp;&amp;180*ROT/PI&gt;90&amp;&amp;(offset="right"),label(a,"A",offset),label(b,"B",offset)</div>
            </div>
            <div class="solution" data-type="custom">
                <div class="instruction">Usa el compás y la regla para construir una mediatriz de <code>\overline{AB}</code>.</div>
                <div class="guess">getToolProperties(construction)</div>
                <div class="validator-function">return 0===guess.length?"":(perp=null,_.each(guess,function(e){null!=e.first&amp;&amp;(ang=atan2(e.second.coord[1]-e.first.coord[1],e.second.coord[0]-e.first.coord[0]),deg=180*ang/PI,origDeg=180*ROT/PI,(abs(deg-origDeg+90)%360&lt;7||abs(deg-origDeg-90)%360&lt;7)&amp;&amp;(perp=e))}),null==perp?!1:(comps=_.filter(guess,function(e){return null!=e.center}),comps.length&lt;2?!1:(onLine=[],_.each(comps,function(e){_.each(comps,function(r){thisSlope=(e.center.coord[1]-r.center.coord[1])/(e.center.coord[0]-r.center.coord[0]),thisYInt=e.center.coord[1]-thisSlope*e.center.coord[0],abs(thisSlope-SLOPE)&lt;.5&amp;&amp;abs(thisYInt)&lt;.1&amp;&amp;abs(e.radius-r.radius)&lt;.1&amp;&amp;(onLine=[e,r])})}),onLine.length&lt;2?!1:(interYInt=0,perpYInt=perp.first.coord[1]+perp.first.coord[0]*(1/SLOPE),abs(interYInt-perpYInt)&lt;.5))))</div>
                <div class="show-guess">showConstructionGuess(guess)</div>
            </div>
            <div class="hints">
                <div>
                    <div class="graphie" data-update="construction">graph.perp=raphael.set(),graph.perp.push(line(applyRefFrame([0,10],ROT),applyRefFrame([0,-10],ROT),{strokeWidth:1,stroke:BLUE})).toBack()</div>
                    <p>
                        We could just draw a line and <em>try</em> to get it
                        right, but then <strong>we have no guarantee</strong>
                        that it's actually perfectly perpendicular or that it
                        bisects the segment at exactly the midpoint.
                    </p>
                    <p>¿Cómo puedes garantizar que una línea es realmente una bisectriz?</p>
                </div>
                <div>
                    <div class="graphie" data-update="construction">graph.hintLines=raphael.set(),style({fill:BLUE,stroke:null},function(){graph.perpPoint1=circle(applyRefFrame([0,-1],ROT),.08),graph.perpPoint2=circle(applyRefFrame([0,1],ROT),.08)}),graph.perp.push(drawHintLine(applyRefFrame([0,0],ROT),applyRefFrame([0,1],ROT),1)),graph.perp.push(drawHintLine(applyRefFrame([0,0],ROT),applyRefFrame([0,-1],ROT),1)),graph.hintLines.push(drawHintLine(applyRefFrame([0,-1],ROT),applyRefFrame([1.5,0],ROT),2)),graph.hintLines.push(drawHintLine(applyRefFrame([0,1],ROT),applyRefFrame([1.5,0],ROT),2)),graph.hintLines.push(drawHintLine(applyRefFrame([0,-1],ROT),applyRefFrame([-1.5,0],ROT),2)),graph.hintLines.push(drawHintLine(applyRefFrame([0,1],ROT),applyRefFrame([-1.5,0],ROT),2)),graph.perp.toBack(),graph.hintLines.toBack(),graph.perpPoint1.toBack(),graph.perpPoint2.toBack()</div>
                    <p>Si elegimos <span class="hint_blue"> dos puntos</span> sobre la mediatriz que están a la misma distancia de la intersección, también estarán a la misma distancia de los dos extremos del segmento con el que empezamos.</p>
                </div>
                <div>
                    <div class="graphie" data-update="construction">graph.perp.remove()</div>
                    <p>Si todavía no tenemos la mediatriz, ¿hay alguna otra forma de encontrar los puntos azules?</p>
                </div>
                <div>
                    <div class="graphie" data-update="construction">circle(applyRefFrame([1.5,0],ROT),.08,{fill:GRAY,stroke:null}),graph.compass1=circle(applyRefFrame([1.5,0],ROT),eDist(applyRefFrame([0,-1],ROT),applyRefFrame([1.5,0],ROT)),{stroke:GRAY,strokeWidth:1,fill:"none",strokeDasharray:"- "}).toBack()</div>
                    <p>Si utilizamos el compás para poner un círculo centrado en el punto <code>A</code>, el círculo incluirá todos los puntos que están a la misma distancia del punto <code>A</code>, incluyendo los dos puntos azules.</p>
                </div>
                <div>
                    <div class="graphie" data-update="construction">circle(applyRefFrame([-1.5,0],ROT),.08,{fill:GRAY,stroke:null}),graph.compass2=circle(applyRefFrame([-1.5,0],ROT),eDist(applyRefFrame([0,-1],ROT),applyRefFrame([-2,0],ROT)),{stroke:GRAY,strokeWidth:1,fill:"none",strokeDasharray:"- "}).toBack()</div>
                    <p>Podemos agregar un segundo círculo en el punto <code>B</code> que intersecta con el primer círculo.</p>
                </div>
                <div>
                    <div class="graphie" data-update="construction">graph.hintLines.remove()</div>
                    <p>¡Pero espera! Podemos utilizar estos círculos para dibujar una línea perpendicular, <strong> pero no una bisectriz. </strong> Eso es porque los círculos son de diferentes tamaños.</p>
                </div>
                <div>
                    <div class="graphie" data-update="construction">graph.compass1.animate({rx:scaleVector(3)[0],ry:scaleVector(3)[1]},250),graph.compass2.animate({rx:scaleVector(3)[0],ry:scaleVector(3)[1]},250),graph.perpPoint1.animate({cx:scalePoint(applyRefFrame([0,-1.5*sqrt(3)],ROT))[0],cy:scalePoint(applyRefFrame([0,-1.5*sqrt(3)],ROT))[1]},250),graph.perpPoint2.animate({cx:scalePoint(applyRefFrame([0,1.5*sqrt(3)],ROT))[0],cy:scalePoint(applyRefFrame([0,1.5*sqrt(3)],ROT))[1]},250)</div>
                    <p>Una buena manera de hacer los círculos del mismo tamaño es hacer que los radios sean iguales a la distancia entre <code>A</code> y <code>B</code>. Para hacer esto puedes fijar  el centro del círculo en un punto y el borde del círculo en el otro punto.</p>
                </div>
                <div>
                    <div class="graphie" data-update="construction">graph.perpPoint1.attr({fill:GRAY}),graph.perpPoint2.attr({fill:GRAY}),line(applyRefFrame([0,10],ROT),applyRefFrame([0,-10],ROT),{strokeWidth:1,stroke:GRAY,strokeDasharray:"- "}).toBack()</div>
                    <p>Usa una regla para conectar los dos puntos donde se cruzan los círculos. Esta línea es la mediatriz de <code>\overline{AB}</code>.</p>
                </div>
            </div>
        </div>

        <div id="angle-bisect">
            <div class="vars" data-apply="replace">
                <var id="ROT">randRange(30, 80) * PI / 180</var>
                <var id="CENTER">[randRange(-3, 0), 0]</var>
                <var id="HGRAPH">1</var>
                <var id="A">CENTER</var>
                <var id="B">[CENTER[0] + 4, CENTER[1]]</var>
                <var id="C">function(){var e=applyRefFrame([4,0],ROT);return e=[e[0]+CENTER[0],e[1]+CENTER[1]],e=[roundToNearest(.01,e[0]),roundToNearest(.01,e[1])]}()</var>
            </div>
            <div class="problem">
                <form>
                    <input onclick="javascript: KhanUtil.construction.addCompass();" type="button" value="Utilizar el compás"><input onclick="javascript: KhanUtil.construction.addStraightedge();" type="button" value="Utilizar la regla"><input onclick="javascript: KhanUtil.construction.removeAllTools();" type="button" value="Borrar">
</form>
                <p class="question">Construye la bisectriz para el ángulo dado.</p>
                <div class="graphie" id="construction">init({range:[[-5,5],[-2,5]],scale:50}),addMouseLayer(),addConstruction("construction"),addDummyRay(A,B),addDummyRay(A,C)</div>
            </div>
            <div class="solution" data-type="custom">
                <div class="instruction">Utiliza la regla y el compás para construir la bisectriz de un ángulo.</div>
                <div class="guess">getToolProperties(construction)</div>
                <div class="validator-function">if(0===guess.length)return"";var e=null;if(_.each(guess,function(r){null!=r.first&amp;&amp;(ang=atan2(r.second.coord[1]-r.first.coord[1],r.second.coord[0]-r.first.coord[0]),ang=0&gt;ang?ang+PI:ang,abs(ROT/2-ang)&lt;3*PI/180&amp;&amp;(e=r))}),null==e)return!1;var r=null,a=null,t=null,s=_.filter(guess,function(e){return null!=e.center});if(s.length&lt;3)return!1;if(_.each(s,function(e){eDist(e.center.coord,CENTER)&lt;.5&amp;&amp;(r=e)}),null==r)return!1;var n=[];_.each(s,function(e){n=[CENTER[0]+r.radius,CENTER[1]],eDist(e.center.coord,n)&lt;.5&amp;&amp;(a=e)});var i=[];return _.each(s,function(e){i=[CENTER[0]+applyRefFrame([r.radius,0],ROT)[0],CENTER[1]+applyRefFrame([r.radius,0],ROT)[1]],eDist(e.center.coord,i)&lt;.5&amp;&amp;(t=e)}),null==a||null==t?!1:abs(a.radius-t.radius)&lt;.5</div>
                <div class="show-guess">showConstructionGuess(guess)</div>
            </div>
            <div class="hints">
                <div>
                    <div class="graphie" data-update="construction">var farPoint=[applyRefFrame([10,0],ROT/2)[0]+CENTER[0],applyRefFrame([10,0],ROT/2)[1]+CENTER[1]];graph.bisect=line(CENTER,farPoint,{stroke:BLUE,strokeWidth:1}),graph.bisect.toBack()</div>
                    <p>Podríamos dibujar una línea y<em>tratar</em> dividir el ángulo, pero eso puede ser difícil de hacer y <strong>no hay garantía</strong> que sea una mediatriz perfecta.</p>
                </div>
                <div>
                    <div class="graphie" data-update="construction">graph.hintLines=raphael.set(),graph.intersect1=[CENTER[0]+2,CENTER[1]],graph.intersect2=[applyRefFrame([2,0],ROT)[0]+CENTER[0],applyRefFrame([2,0],ROT)[1]+CENTER[1]],circle(graph.intersect1,.08,{stroke:null,fill:BLUE}),circle(graph.intersect2,.08,{stroke:null,fill:BLUE}),graph.hintLines.push(drawHintLine(CENTER,graph.intersect1,1)),graph.hintLines.push(drawHintLine(CENTER,graph.intersect2,1)),graph.hintLines.push(drawHintLine(graph.intersect1,[applyRefFrame([2.5,0],ROT/2)[0]+CENTER[0],applyRefFrame([2.5,0],ROT/2)[1]+CENTER[1]],2)),graph.hintLines.push(drawHintLine(graph.intersect2,[applyRefFrame([2.5,0],ROT/2)[0]+CENTER[0],applyRefFrame([2.5,0],ROT/2)[1]+CENTER[1]],2)),graph.hintLines.push(drawHintLine(graph.intersect1,[applyRefFrame([4,0],ROT/2)[0]+CENTER[0],applyRefFrame([4,0],ROT/2)[1]+CENTER[1]],3)),graph.hintLines.push(drawHintLine(graph.intersect2,[applyRefFrame([4,0],ROT/2)[0]+CENTER[0],applyRefFrame([4,0],ROT/2)[1]+CENTER[1]],3)),graph.hintLines.toBack()</div>
                    <p>Si elegimos <span class="hint_blue">cualquiera de los dos puntos en las líneas dadas</span>que están a la misma distancia desde el vértice del ángulo, cada punto en la mediatriz será equidistante desde esos puntos.</p>
                </div>
                <div>
                    <div class="graphie" data-update="construction">circle(CENTER,.08,{stroke:null,fill:GRAY}),circle(CENTER,2,{fill:null,stroke:GRAY,strokeWidth:1,strokeDasharray:"- "})</div>
                    <p>Podemos usar el compás centrado en la cima para encontrar <span class="hint_blue"> dos puntos equidistantes del vértice</span>.</p>
                </div>
                <div>
                    <div class="graphie" data-update="construction">graph.bisect.remove(),circle(graph.intersect1,.08,{stroke:null,fill:GRAY}),graph.compass1=circle(graph.intersect1,1.5,{fill:null,stroke:GRAY,strokeWidth:1,strokeDasharray:"- "}),circle(graph.intersect2,.08,{stroke:null,fill:GRAY}),graph.compass2=circle(graph.intersect2,1.8,{fill:null,stroke:GRAY,strokeWidth:1,strokeDasharray:"- "}),graph.hintLines.remove()</div>
                    <p>Si usamos dos o más compases centrar en cada uno de los <span class="hint_blue">dos puntos</span>, podemos ver que se cruzan, <strong>¡pero no sólo en la bisectriz del ángulo!</strong> Eso es porque los dos círculos no son del mismo tamaño.</p>
                </div>
                <div>
                    <div class="graphie" data-update="construction">graph.compass1.animate({rx:scaleVector(2)[0],ry:scaleVector(2)[1]},250),graph.compass2.animate({rx:scaleVector(2)[0],ry:scaleVector(2)[1]},250)</div>
                    <p>Una buena forma de hacer círculos del mismo tamaño es poner los bordes juntos para que así pasen a través del vértice.</p>
                </div>
                <div>
                    <div class="graphie" data-update="construction">circle([CENTER[0]+2+2*cos(ROT),CENTER[1]+2*sin(ROT)],.08,{stroke:null,fill:GRAY}),line([applyRefFrame([-10,0],ROT/2)[0]+CENTER[0],applyRefFrame([-10,0],ROT/2)[1]+CENTER[1]],[applyRefFrame([10,0],ROT/2)[0]+CENTER[0],applyRefFrame([10,0],ROT/2)[1]+CENTER[1]],{stroke:GRAY,strokeWidth:1,strokeDasharray:"- "})</div>
                    <p>Usa una regla para conectar el vértice hasta el punto donde los dos últimos círculos se cruzan. Esta línea es la bisectriz del ángulo.</p>
                </div>
            </div>
        </div>

        <div id="copy-segment">
            <div class="vars">
                <var id="LENGTH">randRange(3, 6) / 2</var>
                <var id="DY">randRange(2, 4) / 2</var>
                <var id="A">applyRefFrame([LENGTH / 2, -DY], ROT)</var>
                <var id="B">applyRefFrame([-LENGTH / 2, -DY], ROT)</var>
                <var id="P">applyRefFrame([0, DY], ROT)</var>
            </div>

            <div class="problem">
                <form>
                    <input onclick="javascript: KhanUtil.construction.addCompass();" type="button" value="Utilizar el compás"><input onclick="javascript: KhanUtil.construction.addStraightedge(false);" type="button" value="Utilizar la regla"><input onclick="javascript: KhanUtil.construction.removeAllTools();" type="button" value="Borrar">
</form>
                <p class="question">Construye una línea que tenga la misma longitud que <code>\overline{AB}</code>, con un extremo en <code>P</code>.</p>
                <div class="graphie" id="construction">init({range:[[-5,5],[-5,5]],scale:50}),addMouseLayer(),addConstruction("construction"),addDummyStraightedge(A,B,!1),addDummyPoint(A),addDummyPoint(B),addDummyPoint(P);var label_position=abs(SLOPE)&gt;1.5?"left":"below";label(A,"A",label_position),label(B,"B",label_position),label(P,"P","below")</div>
            </div>

            <div class="solution" data-type="custom">
                <div class="instruction">Usa el compás y la regla  para construir una recta de la misma longitud que <code>\overline{AB}</code>.</div>
                <div class="guess">getToolProperties(construction)</div>
                <div class="validator-function">if(0===guess.length)return"";var e=_.any(guess,function(e){return null!=e.first&amp;&amp;(eDist(e.first.coord,P)&lt;.5||eDist(e.second.coord,P)&lt;.5)&amp;&amp;abs(eDist(e.first.coord,e.second.coord)-LENGTH)&lt;.5});if(!e)return!1;var r=findCompass(guess,{cx:P[0],cy:P[1],radius:LENGTH});return 1===r.length</div>
                <div class="show-guess">showConstructionGuess(guess)</div>
            </div>

            <div class="hints">
                <div>
                    <div class="graphie" data-update="construction">graph.p1=[P[0]+LENGTH*cos(ROT),P[1]+LENGTH*sin(ROT)],graph.segment=line(P,graph.p1,{strokeWidth:1,stroke:BLUE,extend:!1}).toBack(),graph.lineEnd=circle(graph.p1,.08,{stroke:null,fill:BLUE})</div>
                    <p>Podríamos dibujar una línea en <code>P</code> y <em>tratar de</em> hacerla de la misma longitud que <code>\overline{AB}</code>, pero entonces <strong>no tenemos ninguna garantía de</strong> que es en realidad la misma longitud.</p>
                    <p>¿Cómo podríamos encontrar todos los puntos de la longitud correcta de <code>P</code>?</p>
                </div>

                <div>
                    <div class="graphie" data-update="construction">graph.segment.remove(),graph.lineEnd.remove(),graph.compassVertex=circle(A,.08,{stroke:null,fill:GRAY}),graph.compassCircumference=circle(A,LENGTH,{fill:null,stroke:GRAY,strokeWidth:1,strokeDasharray:"- "})</div>
                    <p>Si centramos el compás en <code>A</code>  y fijamos su radio tal éste intersecte a <code>A</code>, entonces tendremos un compás con un radio de longitud correcta.</p>
                </div>

                <div>
                    <div class="graphie" data-update="construction">graph.compassVertex.animate({cx:scalePoint(P)[0],cy:scalePoint(P)[1]},1e3),graph.compassCircumference.animate({cx:scalePoint(P)[0],cy:scalePoint(P)[1]},1e3)</div>
                    <p>Ahora podemos mover el compás a <code>P</code>.</p>
                </div>


                <div>
                    <div class="graphie" data-update="construction">graph.segment=line(P,graph.p1,{strokeWidth:1,stroke:BLUE,extend:!1}).toBack(),graph.lineEnd=circle(graph.p1,.08,{stroke:null,fill:BLUE})</div>
                    <p>Finalmente, usa una línea recta para conectar el punto <code>P</code> a cualquier punto de la circunferencia que traza el compás.</p>
                </div>
            </div>
        </div>

        <div id="copy-angle">
            <div class="vars" data-apply="replace">
                <var id="ROT">randRange(30, 80) * PI / 180</var>
                <var id="CENTER">[randFromArray([-2, 2]), 0]</var>
                <var id="HGRAPH">1</var>
                <var id="A">[CENTER[0] - 1.5, CENTER[1]]</var>
                <var id="B">[CENTER[0] + 1.5, CENTER[1]]</var>
                <var id="C">function(){var e=applyRefFrame([3,0],ROT);return e=[e[0]+A[0],e[1]+CENTER[1]],e=[roundToNearest(.01,e[0]),roundToNearest(.01,e[1])]}()</var>
                <var id="P">[-CENTER[0] - 1, 2.5]</var>
            </div>
            <div class="problem">
                <form>
                    <input onclick="javascript: KhanUtil.construction.addCompass();" type="button" value="Utilizar el compás"><input onclick="javascript: KhanUtil.construction.addStraightedge(false);" type="button" value="Utilizar la regla"><input onclick="javascript: KhanUtil.construction.removeAllTools();" type="button" value="Borrar">
</form>
                <p class="question">Construye una copia del ángulo <code>\angle BAC</code>  con el vértice en el punto <code>P</code>.</p>
                <div class="graphie" id="construction">init({range:[[-5,5],[-2,5]],scale:50}),addMouseLayer(),addConstruction("construction"),addDummyRay(A,B),addDummyRay(A,C),addDummyPoint(P),label(A,"A","below"),label(B,"B","below"),label(C,"C","above"),label(P,"P","below")</div>
            </div>
            <div class="solution" data-type="custom">
                <div class="instruction">Usa el compás y la regla  para copiar el ángulo <code>\angle BAC</code> en el punto <code>P</code>.</div>
                <div class="guess">getToolProperties(construction)</div>
                <div class="validator-function">if(0===guess.length)return"";var e=_.filter(guess,function(e){return null!=e.first&amp;&amp;(eDist(e.first.coord,P)&lt;.5||eDist(e.second.coord,P)&lt;.5)});if(2!==e.length)return!1;var r=_.map(e,function(e){var r,a;return eDist(e.first.coord,P)&lt;.5?(r=e.first.coord,a=e.second.coord):(r=e.second.coord,a=e.first.coord),atan2(r[1]-a[1],r[0]-a[0])}),a=180*r[0]/PI,t=180*r[1]/PI;a+=0&gt;a?180:0,t+=0&gt;t?180:0;var s=min(180-abs(a-t),abs(a-t));if(abs(s-180*ROT/PI)&gt;3)return!1;var n=findCompass(guess,{cx:P[0],cy:P[1]});if(1!==n.length)return!1;var o=n[0].radius,i=[P[0]-o*cos(r[0]),P[1]-o*sin(r[0])],l=[P[0]-o*cos(r[1]),P[1]-o*sin(r[1])],p=(PI-ROT)/2,c=2*o*cos(p),h=findCompass(guess,{cx:i[0],cy:i[1],radius:c}),d=findCompass(guess,{cx:l[0],cy:l[1],radius:c});return 1===h.length||1===d.length</div>
                <div class="show-guess">showConstructionGuess(guess)</div>
            </div>
            <div class="hints">
                <div>
                    <div class="graphie" data-update="construction">line(P,[P[0]+2.5,P[1]],{strokeWidth:1,stroke:BLUE}).toBack(),circle([P[0]+2.5,P[1]],.08,{stroke:null,fill:BLUE})</div>
                    <p>Primero tenemos que dibujar una línea a través de <code>P</code>.</p>
                </div>

                <div>
                    <div class="graphie" data-update="construction">graph.p4=[applyRefFrame([2,0],ROT)[0]+P[0],applyRefFrame([2,0],ROT)[1]+P[1]],graph.hintLines=raphael.set(),graph.hintLines.push(line(P,graph.p4,{strokeWidth:1,stroke:BLUE})).toBack(),graph.hintPoint=circle(graph.p4,.08,{stroke:null,fill:BLUE})</div>
                    <p>Podríamos dibujar una segunda línea a través de <code>P</code> y <em>tratar de</em> hacer el mismo ángulo <code>\angle BAC</code>, pero eso es algo difícil de hacer y <strong>que no habría garantía</strong> de que el ángulo será exactamente el mismo.</p>
                </div>

                <div>
                    <div class="graphie" data-update="construction">graph.p1=[A[0]+2,A[1]],graph.p2=[applyRefFrame([2,0],ROT)[0]+A[0],applyRefFrame([2,0],ROT)[1]+A[1]],graph.p3=[P[0]+2,P[1]],circle(graph.p1,.08,{stroke:null,fill:BLUE}),circle(graph.p2,.08,{stroke:null,fill:BLUE}),drawHintLine(A,graph.p1,2).toBack(),drawHintLine(A,graph.p2,2).toBack(),graph.hintLines.push(drawHintLine(graph.p1,graph.p2,1)),graph.hintLines.push(drawHintLine(graph.p3,graph.p4,1)),graph.hintLines.push(drawHintLine(P,graph.p3,2)),graph.hintLines.push(drawHintLine(P,graph.p4,2)),graph.hintLines.toBack()</div>
                    <p>Si construimos <span class="hint_blue">un triángulo</span> con un vértice en el punto <code>A</code>, y después construimos un triángulo con las mismas longitudes en el punto <code>P</code>, los ángulos en <code>A</code> y <code>P</code> serán los mismos.</p>
                </div>

                <div>
                    <div class="graphie" data-update="construction">graph.hintLines.remove(),graph.hintPoint.remove(),circle(A,.08,{stroke:null,fill:GRAY}),circle(A,2,{fill:null,stroke:GRAY,strokeWidth:1,strokeDasharray:"- "})</div>
                    <p>Podemos usar compás centrado en <code>A</code>  y encontrar <span class="hint_blue"> dos puntos equidistantes a <code>A</code></span>.</p>
                </div>

                <div>
                    <div class="graphie" data-update="construction">var compassVertex=circle(A,.08,{stroke:null,fill:GRAY}),compassCircumference=circle(A,2,{fill:null,stroke:GRAY,strokeWidth:1,strokeDasharray:"- "});compassVertex.animate({cx:scalePoint(P)[0],cy:scalePoint(P)[1]},1e3),compassCircumference.animate({cx:scalePoint(P)[0],cy:scalePoint(P)[1]},1e3),circle(graph.p3,.08,{stroke:null,fill:BLUE}),drawHintLine(P,graph.p3,2)</div>
                    <p>Podemos utilizar un compás <strong>con el mismo radio</strong> centrado en <code>P</code> para encontrar todos los puntos que se encuentran a la misma distancia de <code>P</code>. Para asegurarnos de tener el mismo radio, primero ponemos el compás en el punto <code>A</code>, ajustamos el radio para que sean iguales, y luego movemos el compás al punto <code>P</code>.</p>
                </div>

                <div>
                    <div class="graphie" data-update="construction">graph.compassVertex=circle(graph.p1,.08,{stroke:null,fill:GRAY}),graph.compassCircumference=circle(graph.p1,eDist(graph.p1,graph.p2),{fill:null,stroke:GRAY,strokeWidth:1,strokeDasharray:"- "})</div>
                    <p>Para encontrar la distancia entre los <span class="hint_blue"> dos puntos equidistantes de <code>A</code></span>, podemos agregar el centro del compás en un punto  y mover el radio hasta que toque el otro punto.</p>
                </div>

                <div>
                    <div class="graphie" data-update="construction">graph.compassVertex.animate({cx:scalePoint(graph.p3)[0],cy:scalePoint(graph.p3)[1]},1e3),graph.compassCircumference.animate({cx:scalePoint(graph.p3)[0],cy:scalePoint(graph.p3)[1]},1e3)</div>
                    <p>Ahora mueve el compás hasta el punto donde el trazo del primer compás intersecta la línea que pasa por <code>P</code>.</p>
                </div>

                <div>
                    <div class="graphie" data-update="construction">var dx=10*cos(ROT),dy=10*sin(ROT);drawHintLine(P,graph.p4,2),drawHintLine(graph.p3,graph.p4,1),line(P,graph.p4,{strokeWidth:1,stroke:BLUE}).toBack(),line(P,graph.p4,{strokeWidth:1,stroke:BLUE}).toBack(),circle(graph.p4,.08,{stroke:null,fill:BLUE})</div>
                    <p>Finalmente, usa una regla para conectar el punto <code>P</code> al punto donde se intersectan los trazos de los dos compases. El ángulo formado en el punto <code>P</code>  será el mismo que <code>\angle BAC</code>.</p>
                </div>
            </div>
        </div>
    </div>
    </div>
</body>
</html>
