<!DOCTYPE html>
<html data-require="math graphie geom interactive">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<title>Rotación de polígonos</title>
<script src="../khan-exercise.js"></script>
</head>
<body>
<div class="exercise">
    <div class="vars">
        <var id="ROTDEG">90 * randRange(1, 3)</var>
        <var id="ROTRAD">ROTDEG * PI / 180 </var>
        <var id="HULL">Geom.convexhull(_.map(randRange(-4,4,6,2),function(e){return{x:e[0],y:e[1]}}))</var>
        <var id="HULL_POINTS">_.map(HULL, function(p) { return [p.x, p.y]; })</var>
        <var id="TARGET">_.map(HULL,function(e){return[e.x*cos(ROTRAD)-e.y*sin(ROTRAD),e.x*sin(ROTRAD)+e.y*cos(ROTRAD)]})</var>
    </div>

    <div class="problems">
        <div id="drag">
            <p class="question">¿Cuál es la imagen del polígono siguiente después de la rotación <code>T_{{<var>ROTDEG</var>}^\circ{} }</code>?</p>

            <div class="problem">
                <div class="graphie" id="grid">graphInit({range:11,scale:20,axisArrows:"&lt;-&gt;",tickStep:1,labelStep:1,gridOpacity:.05,axisOpacity:.2,tickOpacity:.4,labelOpacity:.5}),addMouseLayer(),path(HULL_POINTS.concat(!0),{stroke:GRAY,strokeDasharray:"- "}),graph.points=_.map(HULL_POINTS,function(e){return addMovablePoint({coord:e})}),graph.lines=[],_(graph.points.length).times(function(e){graph.lines.push(addMovableLineSegment({pointA:graph.points[e],pointZ:graph.points[(e+1)%graph.points.length],fixed:!0}))}),graph.origOffsets=_.map(graph.points,function(e){return atan2(e.coord[1],e.coord[0])-roundToNearest(PI/6,atan2(e.coord[1],e.coord[0]))}),_.each(graph.points,function(e){e.onMove=function(e,r){var a=atan2(this.coord[1],this.coord[0]),n=atan2(r,e);return graph.updatePolygon(n-a),!1},e.onMoveEnd=function(e,r){var a=[graph.origOffsets[_.indexOf(graph.points,this)]+roundToNearest(PI/6,atan2(r,e))-atan2(this.coord[1],this.coord[0]),graph.origOffsets[_.indexOf(graph.points,this)]+roundToNearest(PI/6,atan2(r,e))+PI/6-atan2(this.coord[1],this.coord[0]),graph.origOffsets[_.indexOf(graph.points,this)]+roundToNearest(PI/6,atan2(r,e))-PI/6-atan2(this.coord[1],this.coord[0])],n=_.map(a,function(e){return abs(e)}),t=min(n[0],n[1],n[2]),s=_.find(a,function(e){return abs(e)===t});graph.updatePolygon(s)}}),graph.updatePolygon=function(e){_.each(graph.points,function(r){r.setCoord([r.coord[0]*cos(e)-r.coord[1]*sin(e),r.coord[0]*sin(e)+r.coord[1]*cos(e)]),r.updateLineEnds()})}</div>
            </div>

            <div class="solution" data-type="custom">
                <div class="instruction">Rota el polígono azul hasta su imagen bajo la traslación dada.</div>
                <div class="guess">_.map(graph.points,function(e){return e.coord})</div>
                <div class="validator-function">var e=function(e,r){return e=_.sortBy(e,function(e){return 100*e[0]+e[1]}),r=_.sortBy(r,function(e){return 100*e[0]+e[1]}),_.all(e,function(a,n){return abs(e[n][0]-r[n][0])&lt;.01&amp;&amp;abs(e[n][1]-r[n][1])&lt;.01})};return e(guess,HULL_POINTS)?"":e(guess,TARGET)</div>
                <div class="show-guess">_.each(graph.points,function(e,r){e.setCoord(guess[r]),e.updateLineEnds()})</div>
            </div>

            <div class="hints">
                <p>Una rotación <code>T_{\LARGE r^\circ{}}</code> rota los puntos <code>r</code> grados al rededor de <code>(0,0)</code> al contrario de las manecillas del reloj.</p>
                <div>
                    <p>Para ver cómo movió una rotación al polígono, elige un ponto y rótalo. Por ejemplo, ¿qué pasó con <code>(<var> HULL[0].x </var>,<var> HULL[0].y </var>)</code> con esta rotación?</p>
                    <div class="graphie" data-update="grid">circle([HULL[0].x,HULL[0].y],{r:.2,fill:"black",stroke:"none"})</div>
                </div>
                <div>
                    <p>Bajo la rotación <code>T_{<var>ROTDEG</var> {}^\circ{} }</code>, <code>(<var> HULL[0].x </var>,<var> HULL[0].y </var>)</code> se traslada a <code>(<var> round(TARGET[0][0]) </var>, <var>round(TARGET[0][1])</var>)</code>. ¿Hacia dónde rota el resto del polígono?</p>
                    <div class="graphie" data-update="grid">circle(TARGET[0],{r:.2,fill:"black",stroke:"none"}),arc([0,0],sqrt(pow(HULL[0].x,2)+pow(HULL[0].y,2)),180*atan2(HULL[0].y,HULL[0].x)/PI,180*atan2(TARGET[0][1],TARGET[0][0])/PI,{stroke:"black",arrows:"-&gt;"})</div>
                </div>
                <p>
                    <span data-if="ROTDEG / 90 === 1">Para ir de <code>(<var>HULL[0].x</var>, <var>HULL[0].y</var>)</code> a <code>(<var>round(TARGET[0][0])</var>, <var>round(TARGET[0][1])</var>)</code>, lo rotamos <code><var>ROTDEG</var>{}^\circ{}</code> en contra de las manecillas del reloj, o un cuarto de circunferencia.</span>
                    <span data-else-if="ROTDEG / 90 === 2">Para ir de <code>(<var>HULL[0].x</var>, <var>HULL[0].y</var>)</code> a <code>(<var>round(TARGET[0][0])</var>, <var>round(TARGET[0][1])</var>)</code>, lo rotamos <code><var>ROTDEG</var>{}^\circ{}</code> en contra de las manecillas del reloj, o media circunferencia.</span>
                    <span data-else-if="ROTDEG / 90 === 3">Para ir de <code>(<var>HULL[0].x</var>, <var>HULL[0].y</var>)</code> a <code>(<var>round(TARGET[0][0])</var>, <var>round(TARGET[0][1])</var>)</code>, lo rotamos <code><var>ROTDEG</var>{}^\circ{}</code> en contra de las manecillas del reloj, o tres cuartos de circunferencia.</span>
                </p>
                <div>
                    <p>El contorno anaranjado muestra dónde queda el polígono después de la traslación.</p>
                    <div class="graphie" data-update="grid">for(var i=0;i&lt;TARGET.length;i++)line(TARGET[i],TARGET[(i+1)%TARGET.length],{stroke:ORANGE})</div>
                </div>
            </div>
        </div>


        <div id="reverse">
            <p class="question">¿Cuál es la transformación que rota la figura azul a la figura anaranjada punteada?</p>

            <div class="problem">
                <div class="graphie" id="grid">graphInit({range:11,scale:20,axisArrows:"&lt;-&gt;",tickStep:1,labelStep:1,gridOpacity:.05,axisOpacity:.2,tickOpacity:.4,labelOpacity:.5}),path(HULL_POINTS.concat(!0),{stroke:BLUE}),path(TARGET.concat(!0),{stroke:ORANGE,strokeDasharray:"- "})</div>
            </div>

            <div class="solution" data-type="multiple">
                <code>{\LARGE T}</code>
                <span class="sol short30" data-forms="integer" data-type="predicate">
                    function(guess, maxError) {
                        var correct = false;
                        var symmetries = _.map(Geom.rotationalSymmetries(HULL), function(rad) {
                            return rad / PI * 180;
                        }).concat(360);
                        return _.any(symmetries, function(sym) {
                            return abs((((guess - ROTDEG + sym) % 360) + 360 + 180) % 360 - 180) &lt; maxError;
                        });
                    }
                </span>
                <code>{}^\circ{}</code>
            </div>

            <div class="hints">
                <p>Una rotación <code>T_{\LARGE r^\circ{}}</code> rota los puntos <code>r</code> grados al rededor de <code>(0, 0)</code> al contrario de las manecillas del reloj.</p>
                <div>
                    <p>Para ver qué rotación movió al polígono azul, elige un punto y rótalo. Por ejemplo, ¿qué pasó con <code>(<var>HULL[0].x</var>, <var>HULL[0].y</var>)</code> con esta rotación?</p>
                    <div class="graphie" data-update="grid">circle([HULL[0].x,HULL[0].y],{r:.2,fill:"black",stroke:"none"})</div>
                </div>
                <div>
                    <p>Bajo esta rotación, <code>(<var>HULL[0].x</var>, <var>HULL[0].y</var>)</code> fue rotado a <code>(<var>round(TARGET[0][0])</var>, <var>round(TARGET[0][1])</var>)</code>. ¿Qué te dice esto sobre la rotación usada?</p>
                    <div class="graphie" data-update="grid">circle(TARGET[0],{r:.2,fill:"black",stroke:"none"}),arc([0,0],sqrt(pow(HULL[0].x,2)+pow(HULL[0].y,2)),180*atan2(HULL[0].y,HULL[0].x)/PI,180*atan2(TARGET[0][1],TARGET[0][0])/PI,{stroke:"black",arrows:"-&gt;"})</div>
                </div>
                <p>Para ir de <code>(<var>HULL[0].x</var>, <var>HULL[0].y</var>)</code> a <code>(<var>round(TARGET[0][0])</var>, <var>round(TARGET[0][1])</var>)</code>, lo rotamos alrededor de <code>(0, 0)</code> <code><var>ROTDEG</var>{}^\circ{}</code> en contra de las manecillas del reloj.</p>
                <div>La rotación usada fue <code>T_{<var>ROTDEG</var>^\circ{}}</code>.</div>
            </div>
        </div>
    </div>
</div>
</body>
</html>
