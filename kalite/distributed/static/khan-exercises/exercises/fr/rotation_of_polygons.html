<!DOCTYPE html>
<html data-require="math graphie geom interactive">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<title>Rotation d'un polygone</title>
<script src="../khan-exercise.js"></script>
</head>
<body>
<div class="exercise">
    <div class="vars">
        <var id="ROTDEG">90 * randRange(1, 3)</var>
        <var id="ROTRAD">ROTDEG * PI / 180 </var>
        <var id="HULL">Geom.convexhull(_.map(randRange(-4,4,6,2),function(e){return{x:e[0],y:e[1]}}))</var>
        <var id="HULL_POINTS">_.map(HULL, function(p) { return [p.x, p.y]; })</var>
        <var id="TARGET">_.map(HULL,function(e){return[e.x*cos(ROTRAD)-e.y*sin(ROTRAD),e.x*sin(ROTRAD)+e.y*cos(ROTRAD)]})</var>
    </div>

    <div class="problems">
        <div id="drag">
            <p class="question">Quelle est l'image du polygone ci-dessous par la rotation <code>T_{{<var>ROTDEG</var>}^\circ{} }</code>?</p>

            <div class="problem">
                <div class="graphie" id="grid">graphInit({range:11,scale:20,axisArrows:"&lt;-&gt;",tickStep:1,labelStep:1,gridOpacity:.05,axisOpacity:.2,tickOpacity:.4,labelOpacity:.5}),addMouseLayer(),path(HULL_POINTS.concat(!0),{stroke:GRAY,strokeDasharray:"- "}),graph.points=_.map(HULL_POINTS,function(e){return addMovablePoint({coord:e})}),graph.lines=[],_(graph.points.length).times(function(e){graph.lines.push(addMovableLineSegment({pointA:graph.points[e],pointZ:graph.points[(e+1)%graph.points.length],fixed:!0}))}),graph.origOffsets=_.map(graph.points,function(e){return atan2(e.coord[1],e.coord[0])-roundToNearest(PI/6,atan2(e.coord[1],e.coord[0]))}),_.each(graph.points,function(e){e.onMove=function(e,r){var a=atan2(this.coord[1],this.coord[0]),n=atan2(r,e);return graph.updatePolygon(n-a),!1},e.onMoveEnd=function(e,r){var a=[graph.origOffsets[_.indexOf(graph.points,this)]+roundToNearest(PI/6,atan2(r,e))-atan2(this.coord[1],this.coord[0]),graph.origOffsets[_.indexOf(graph.points,this)]+roundToNearest(PI/6,atan2(r,e))+PI/6-atan2(this.coord[1],this.coord[0]),graph.origOffsets[_.indexOf(graph.points,this)]+roundToNearest(PI/6,atan2(r,e))-PI/6-atan2(this.coord[1],this.coord[0])],n=_.map(a,function(e){return abs(e)}),t=min(n[0],n[1],n[2]),i=_.find(a,function(e){return abs(e)===t});graph.updatePolygon(i)}}),graph.updatePolygon=function(e){_.each(graph.points,function(r){r.setCoord([r.coord[0]*cos(e)-r.coord[1]*sin(e),r.coord[0]*sin(e)+r.coord[1]*cos(e)]),r.updateLineEnds()})}</div>
            </div>

            <div class="solution" data-type="custom">
                <div class="instruction">Faites tourner le polygone jusqu'à son image par la translation donnée.</div>
                <div class="guess">_.map(graph.points,function(e){return e.coord})</div>
                <div class="validator-function">var e=function(e,r){return e=_.sortBy(e,function(e){return 100*e[0]+e[1]}),r=_.sortBy(r,function(e){return 100*e[0]+e[1]}),_.all(e,function(a,n){return abs(e[n][0]-r[n][0])&lt;.01&amp;&amp;abs(e[n][1]-r[n][1])&lt;.01})};return e(guess,HULL_POINTS)?"":e(guess,TARGET)</div>
                <div class="show-guess">_.each(graph.points,function(e,r){e.setCoord(guess[r]),e.updateLineEnds()})</div>
            </div>

            <div class="hints">
                <p>Une rotation  <code>T_{\LARGE r^\circ{}}</code> fait tourner les points de <code>r</code> degrés autour de <code>(0,0)</code> dans le sens des aiguilles d'une montre.</p>
                <div>
                    <p>Pour voir ou a été déplacé ce polygone par la rotation, on choisit un point et on cherche son image. Par exemple, quelle est l'image de <code>(<var> HULL[0].x </var>,<var> HULL[0].y </var>)</code>par cette rotation ?</p>
                    <div class="graphie" data-update="grid">circle([HULL[0].x,HULL[0].y],{r:.2,fill:"black",stroke:"none"})</div>
                </div>
                <div>
                    <p>Par la rotation <code>T_{<var>ROTDEG</var> {}^\circ{} }</code>, <code>(<var> HULL[0].x </var>,<var> HULL[0].y </var>)</code> est déplacé en <code>(<var> round(TARGET[0][0]) </var>, <var>round(TARGET[0][1])</var>)</code>. Où est déplacé le reste du  polygone?</p>
                    <div class="graphie" data-update="grid">circle(TARGET[0],{r:.2,fill:"black",stroke:"none"}),arc([0,0],sqrt(pow(HULL[0].x,2)+pow(HULL[0].y,2)),180*atan2(HULL[0].y,HULL[0].x)/PI,180*atan2(TARGET[0][1],TARGET[0][0])/PI,{stroke:"black",arrows:"-&gt;"})</div>
                </div>
                <p>
                    <span data-if="ROTDEG / 90 === 1">Pour passer de <code>(<var>HULL[0].x</var>, <var>HULL[0].y</var>)</code> à <code>(<var>round(TARGET[0][0])</var>, <var>round(TARGET[0][1])</var>)</code>, on a effectué une rotation <code><var>ROTDEG</var>{}^\circ{}</code> dans le sens des aiguilles d'une montre, c'est à dire selon un quart de cercle.</span>
                    <span data-else-if="ROTDEG / 90 === 2">Pour passer de <code>(<var>HULL[0].x</var>, <var>HULL[0].y</var>)</code> à <code>(<var>round(TARGET[0][0])</var>, <var>round(TARGET[0][1])</var>)</code>, on a effectué une rotation <code><var>ROTDEG</var>{}^\circ{}</code> dans le sens des aiguilles d'une montre, c'est à dire qu'on lui a fait faire un demi-tour.</span>
                    <span data-else-if="ROTDEG / 90 === 3">Pour passer de <code>(<var>HULL[0].x</var>, <var>HULL[0].y</var>)</code> à <code>(<var>round(TARGET[0][0])</var>, <var>round(TARGET[0][1])</var>)</code>, on a effectué une rotation <code><var>ROTDEG</var>{}^\circ{}</code> dans le sens des aiguilles d'une montre, c'est à dire trois quarts de cercle.</span>
                </p>
                <div>
                    <p>Le contour orange indique où le polygone se place après la translation.</p>
                    <div class="graphie" data-update="grid">for(var i=0;i&lt;TARGET.length;i++)line(TARGET[i],TARGET[(i+1)%TARGET.length],{stroke:ORANGE})</div>
                </div>
            </div>
        </div>


        <div id="reverse">
            <p class="question">Quelle est la transformation qui tourne la figure bleue en la figure en pointillés orange ?</p>

            <div class="problem">
                <div class="graphie" id="grid">graphInit({range:11,scale:20,axisArrows:"&lt;-&gt;",tickStep:1,labelStep:1,gridOpacity:.05,axisOpacity:.2,tickOpacity:.4,labelOpacity:.5}),path(HULL_POINTS.concat(!0),{stroke:BLUE}),path(TARGET.concat(!0),{stroke:ORANGE,strokeDasharray:"- "})</div>
            </div>

            <div class="solution" data-type="multiple">
                <code>{\LARGE T}</code>
                <span class="sol short30" data-forms="integer" data-type="predicate">
                    function(guess, maxError) {
                        var correct = false;
                        var symmetries = _.map(Geom.rotationalSymmetries(HULL), function(rad) {
                            return rad / PI * 180;
                        }).concat(360);
                        return _.any(symmetries, function(sym) {
                            return abs((((guess - ROTDEG + sym) % 360) + 360 + 180) % 360 - 180) &lt; maxError;
                        });
                    }
                </span>
                <code>{}^\circ{}</code>
            </div>

            <div class="hints">
                <p>Une rotation  <code>T_{\LARGE r^\circ{}}</code> fait tourner les points de <code>r</code> degrés autour de <code>(0, 0)</code> dans le sens des aiguilles d'une montre.</p>
                <div>
                    <p>Pour voir quelle rotation a été appliquée au polygone bleu, choisis un point et effectue une rotation dessus. Par exemple, qu'est devenu <code>(<var>HULL[0].x</var>, <var>HULL[0].y</var>)</code> par cette rotation?</p>
                    <div class="graphie" data-update="grid">circle([HULL[0].x,HULL[0].y],{r:.2,fill:"black",stroke:"none"})</div>
                </div>
                <div>
                    <p>Par la rotation, <code>(<var>HULL[0].x</var>, <var>HULL[0].y</var>)</code> a été déplacé en <code>(<var>round(TARGET[0][0])</var>, <var>round(TARGET[0][1])</var>)</code>. Qu'est ce que cela nous apprend sur la rotation utilisée?</p>
                    <div class="graphie" data-update="grid">circle(TARGET[0],{r:.2,fill:"black",stroke:"none"}),arc([0,0],sqrt(pow(HULL[0].x,2)+pow(HULL[0].y,2)),180*atan2(HULL[0].y,HULL[0].x)/PI,180*atan2(TARGET[0][1],TARGET[0][0])/PI,{stroke:"black",arrows:"-&gt;"})</div>
                </div>
                <p>Pour passer de <code>(<var>HULL[0].x</var>, <var>HULL[0].y</var>)</code> à <code>(<var>round(TARGET[0][0])</var>, <var>round(TARGET[0][1])</var>)</code>, on a effectué une rotation autour de <code>(0, 0)</code> <code><var>ROTDEG</var>{}^\circ{}</code> dans le sens des aiguilles d'une montre.</p>
                <div>La rotation utilisée était <code>T_{<var>ROTDEG</var>^\circ{}}</code>.</div>
            </div>
        </div>
    </div>
</div>
</body>
</html>
