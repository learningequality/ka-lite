<!DOCTYPE html>
<html data-require="math graphie graphie-geometry interactive constructions kmatrix">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<title>Constructions à la règle et au compas</title>
<script src="../khan-exercise.js"></script><script>
        var applyRefFrame = function(coord, rot) {
            var rotCoord = [];
            rotCoord[0] = Math.cos(rot) * coord[0] - Math.sin(rot) * coord[1];
            rotCoord[1] = Math.sin(rot) * coord[0] + Math.cos(rot) * coord[1];

            return rotCoord;
        };
    </script>
</head>
<body>
    <div class="exercise">
    <div class="vars">
        <var id="ROT">(random() &lt; 0.5 ? randRange(10, 80): randRange(100, 170)) * PI / 180</var>
        <var id="SLOPE">tan(ROT)</var>
        <var id="HGRAPH">0</var>
    </div>

    <div class="problems">
        <div id="perpendicular">
            <div class="problem">
                <form>
                    <input onclick="javascript: KhanUtil.construction.addCompass();" type="button" value="Utiliser un compas"><input onclick="javascript: KhanUtil.construction.addStraightedge();" type="button" value="Tracer une droite"><input onclick="javascript: KhanUtil.construction.removeAllTools();" type="button" value="effacer">
</form>
                <p class="question">Construire une droite perpendiculaire à celle déjà tracée.</p>
                <div class="graphie" id="construction">init({range:[[-5,5],[-5,5]],scale:50}),addMouseLayer(),addConstruction("construction");var a=applyRefFrame([4,0],ROT),b=applyRefFrame([-4,0],ROT);addDummyStraightedge(a,b)</div>
            </div>
            <div class="solution" data-type="custom">
                <div class="instruction">Utiliser la règle et le compas pour tracer une droite perpendiculaire à la droite donnée.</div>
                <div class="guess">getToolProperties(construction)</div>
                <div class="validator-function">if(0===guess.length)return"";if(perp=null,_.each(guess,function(e){null!=e.first&amp;&amp;(ang=atan2(e.second.coord[1]-e.first.coord[1],e.second.coord[0]-e.first.coord[0]),deg=180*ang/PI,origDeg=180*ROT/PI,(abs(deg-origDeg+90)&lt;7||abs(deg-origDeg-90)&lt;7)&amp;&amp;(perp=e))}),null==perp)return!1;if(comps=_.filter(guess,function(e){return null!=e.center}),comps.length&lt;2)return!1;if(onLine=[],_.each(comps,function(e){_.each(comps,function(r){thisSlope=(e.center.coord[1]-r.center.coord[1])/(e.center.coord[0]-r.center.coord[0]),thisYInt=e.center.coord[1]-thisSlope*e.center.coord[0],abs(thisSlope-SLOPE)&lt;.5&amp;&amp;abs(thisYInt)&lt;.1&amp;&amp;(onLine=[e,r])})}),onLine.length&lt;2)return!1;var e=onLine[0].center.coord[0],r=onLine[0].center.coord[1],a=onLine[1].center.coord[0],t=onLine[1].center.coord[1],n=onLine[0].radius,s=onLine[1].radius,i=a-e,l=t-r,o=sqrt(pow(i,2)+pow(l,2)),p=(pow(o,2)+pow(n,2)-pow(s,2))/(2*o),c=e+i*p/o+l/o*sqrt(pow(n,2)-pow(p,2)),h=r+l*p/o-i/o*sqrt(pow(n,2)-pow(p,2));return interYInt=h+c*(1/SLOPE),perpYInt=perp.first.coord[1]+perp.first.coord[0]*(1/SLOPE),abs(interYInt-perpYInt)&lt;1</div>
                <div class="show-guess">showConstructionGuess(guess)</div>
            </div>
            <div class="hints">
                <div>
                    <div class="graphie" data-update="construction">graph.perp=raphael.set(),graph.perp.push(line(applyRefFrame([0,10],ROT),applyRefFrame([0,-10],ROT),{strokeWidth:1,stroke:BLUE})).toBack()</div>
                    <p>On peut juste tracer une droite et <em>essayer</em> de la rendre perpendiculaire, mais alors <strong>on n'a aucune garantie</strong> que ce soit parfaitement perpendiculaire.</p>
                    <p>Comment peut-on affirmer qu'une droite est perpendiculaire ?</p>
                </div>
                <div>
                    <div class="graphie" data-update="construction">graph.perpPoints=raphael.set(),graph.hintLines=raphael.set(),style({fill:BLUE,stroke:null},function(){graph.perpPoints.push(circle(applyRefFrame([0,-1],ROT),.08)),graph.perpPoints.push(circle(applyRefFrame([0,1],ROT),.08))}),graph.perp.push(drawHintLine(applyRefFrame([0,0],ROT),applyRefFrame([0,1],ROT),1)),graph.perp.push(drawHintLine(applyRefFrame([0,0],ROT),applyRefFrame([0,-1],ROT),1)),graph.hintLines.push(drawHintLine(applyRefFrame([0,-1],ROT),applyRefFrame([1,0],ROT),2)),graph.hintLines.push(drawHintLine(applyRefFrame([0,1],ROT),applyRefFrame([1,0],ROT),2)),graph.hintLines.push(drawHintLine(applyRefFrame([0,-1],ROT),applyRefFrame([-2,0],ROT),3)),graph.hintLines.push(drawHintLine(applyRefFrame([0,1],ROT),applyRefFrame([-2,0],ROT),3)),graph.perp.toBack(),graph.hintLines.toBack(),graph.perpPoints.toBack()</div>
                    <p>Si on choisit <span class="hint_blue">deux points</span> sur la médiatrice à égale distance de l'intersection, alors ils seront aussi équidistants de tout point du segment.</p>
                </div>
                <div>
                    <div class="graphie" data-update="construction">graph.perp.remove()</div>
                    <p>Si on ne connait pas encore la droite perpendiculaire, existe-t-il un autre moyen pour   trouver les points bleus ?</p>
                </div>
                <div>
                    <div class="graphie" data-update="construction">circle(applyRefFrame([1,0],ROT),.08,{fill:GRAY,stroke:null}),circle(applyRefFrame([1,0],ROT),eDist(applyRefFrame([0,-1],ROT),applyRefFrame([1,0],ROT)),{stroke:GRAY,strokeWidth:1,fill:"none",strokeDasharray:"- "})</div>
                    <p>Si on utilise le compas pour tracer un cercle de centre n'importe quel point sur la droite, ce cercle sera formé de tous les points situés à égale distance de ce point, y compris les deux points bleus.</p>
                </div>
                <div>
                    <div class="graphie" data-update="construction">circle(applyRefFrame([-2,0],ROT),.08,{fill:GRAY,stroke:null}),circle(applyRefFrame([-2,0],ROT),eDist(applyRefFrame([0,-1],ROT),applyRefFrame([-2,0],ROT)),{stroke:GRAY,strokeWidth:1,fill:"none",strokeDasharray:"- "})</div>
                    <p>On peut tracer un deuxième cercle en un autre point de la droite qui coupe le premier cercle.</p>
                </div>
                <div>
                    <div class="graphie" data-update="construction">graph.hintLines.remove()</div>
                    <p>Les points d'intersection des deux cercles peuvent être utilisés pour tracer une droite perpendiculaire.</p>
                </div>
                <div>
                    <div class="graphie" data-update="construction">graph.perpPoints.attr({fill:GRAY}),line(applyRefFrame([0,10],ROT),applyRefFrame([0,-10],ROT),{strokeWidth:1,stroke:GRAY,strokeDasharray:"- "}).toBack()</div>
                    <p>Utiliser une règle pour relier les deux point où les cercles se croisent. Cette droite est perpendiculaire à la droite donnée.</p>
                </div>
            </div>
        </div>

        <div id="parallel">
            <div class="vars">
                <var id="DEG">ROT * 180/PI - 180</var>
                <var id="DY">randRange(3, 5) / 2</var>
                <var id="A">applyRefFrame([2, -DY], ROT)</var>
                <var id="B">applyRefFrame([-2, -DY], ROT)</var>
                <var id="P">applyRefFrame([0, DY], ROT)</var>
                <var id="R">1.2</var>
            </div>

            <div class="problem">
                <form>
                    <input onclick="javascript: KhanUtil.construction.addCompass();" type="button" value="Utiliser un compas"><input onclick="javascript: KhanUtil.construction.addStraightedge();" type="button" value="Tracer une droite"><input onclick="javascript: KhanUtil.construction.removeAllTools();" type="button" value="effacer">
</form>
                <p class="question">Construire une droite parallèle a la droite donnée et passant par <code>P</code>.</p>
                <div class="graphie" id="construction">init({range:[[-5,5],[-5,5]],scale:50}),addMouseLayer(),addConstruction("construction"),addDummyStraightedge(A,B),addDummyPoint(P),label(P,"P",0&gt;SLOPE?"left":"below")</div>
            </div>

            <div class="solution" data-type="custom">
                <div class="instruction">Construire à la règle et au compas une droite parallèle à la droite donnée.</div>
                <div class="guess">getToolProperties(construction)</div>
                <div class="validator-function">if(0===guess.length)return"";var e=_.filter(guess,function(e){return null!=e.first?isPointOnLineSegment([e.first.coord,e.second.coord],P,.1):void 0});if(e.length&lt;2)return!1;var r=null,a=null,t=_.filter(e,function(e){var t=atan2(e.second.coord[1]-e.first.coord[1],e.second.coord[0]-e.first.coord[0]),n=abs(180*abs(t-ROT)/PI-90);return abs(n-90)&gt;5?(r=t,a=(90-n)*PI/180,!1):!0});if(0===t.length)return!1;var n=findCompass(guess,{cx:P[0],cy:P[1]});if(1!==n.length)return!1;var s=n[0].radius,i=[P[0]-s*cos(r),P[1]-s*sin(r)],l=[P[0]+s*cos(r),P[1]+s*sin(r)],o=2*s*sin(a/2),p=findCompass(guess,{cx:i[0],cy:i[1],radius:o}),c=findCompass(guess,{cx:l[0],cy:l[1],radius:o});return 1===p.length||1===c.length</div>
                <div class="show-guess">showConstructionGuess(guess)</div>
            </div>

            <div class="hints">
                <div>
                    <div class="graphie" data-update="construction">var dx=10*cos(ROT),dy=10*sin(ROT);graph.parallel=raphael.set(),graph.parallel.push(line([P[0]-dx,P[1]-dy],[P[0]+dx,P[1]+dy],{strokeWidth:1,stroke:BLUE})).toBack()</div>
                    <p>On peut juste tracer une ligne passant par <code>P</code> et <em>essayer</em> de la rendre parallèle, mais alors <strong>on n'a aucune garantie</strong> que ce soit parfaitement parallèle.</p>
                </div>

                <div>
                    <div class="graphie" data-update="construction">var d=applyRefFrame([-1,DY],ROT);line([A[0]+10*d[0],A[1]+10*d[1]],[A[0]-10*d[0],A[1]-10*d[1]],{strokeWidth:1,stroke:BLUE}).toBack(),graph.angleAP=atan2(P[1]-A[1],P[0]-A[0]),arc(A,.5,180*graph.angleAP/PI,DEG,!1,{strokeWidth:1,stroke:BLUE}).toBack(),graph.parallel.push(arc(P,.5,180*graph.angleAP/PI,DEG,!1,{strokeWidth:1,stroke:BLUE})),addDummyPoint(A),label(A,"A",0&gt;SLOPE?"above":"below")</div>
                    <p>Si on a deux droites parallèles et que l'on trace une droite depuis un point <code>A</code> situé sur la ligne donnée, passant par <code>P</code>, alors les angles en <code>A</code> et en <code>P</code> seront identiques.</p>
                    <p>Enfin, si on copie l'angle en <code>A</code> au point <code>P</code>, nous serons en mesure de construire des droites parallèles.</p>
                </div>

                <div>
                    <div class="graphie" data-update="construction">var d1=applyRefFrame([-R,0],ROT),d2=applyRefFrame([R,0],graph.angleAP);graph.p1=[A[0]+d1[0],A[1]+d1[1]],graph.p2=[A[0]+d2[0],A[1]+d2[1]],graph.p3=[P[0]+d1[0],P[1]+d1[1]],graph.p4=[P[0]+d2[0],P[1]+d2[1]],circle(graph.p1,.08,{stroke:null,fill:BLUE}),circle(graph.p2,.08,{stroke:null,fill:BLUE}),graph.hintPoint1=circle(graph.p3,.08,{stroke:null,fill:BLUE}),graph.hintPoint2=circle(graph.p4,.08,{stroke:null,fill:BLUE}),drawHintLine(A,graph.p1,2).toBack(),drawHintLine(A,graph.p2,2).toBack(),graph.parallel.push(drawHintLine(graph.p1,graph.p2,1)),graph.parallel.push(drawHintLine(graph.p3,graph.p4,1)),graph.parallel.push(drawHintLine(P,graph.p3,2)),graph.parallel.push(drawHintLine(P,graph.p4,2)),graph.parallel.toBack()</div>
                    <p>Si on construit  <span class="hint_blue">un triangle</span> dont un sommet correspond au point <code>A</code>, puis on construit un triangle avec des côtés de même longueurs et sont un sommet est le point <code>P</code>, alors les angles en <code>A</code> et en <code>P</code> seront identiques.</p>
                </div>

                <div>
                    <div class="graphie" data-update="construction">graph.parallel.remove(),graph.hintPoint1.remove(),graph.hintPoint2.remove(),circle(A,.08,{stroke:null,fill:GRAY}),circle(A,R,{fill:null,stroke:GRAY,strokeWidth:1,strokeDasharray:"- "})</div>
                    <p>On peut utiliser un compas centré en <code>A</code> pour trouver tous les points situés à une distance donnée de <code>A</code>.</p>
                </div>

                <div>
                    <div class="graphie" data-update="construction">var compassVertex=circle(A,.08,{stroke:null,fill:GRAY}),compassCircumference=circle(A,R,{fill:null,stroke:GRAY,strokeWidth:1,strokeDasharray:"- "});compassVertex.animate({cx:scalePoint(P)[0],cy:scalePoint(P)[1]},1e3),compassCircumference.animate({cx:scalePoint(P)[0],cy:scalePoint(P)[1]},1e3)</div>
                    <p>On peut utiliser un compas <strong>avec le même rayon</strong> centré en <code>P</code> pour trouver tous les points à la même distance de <code>P</code>. On peut s'assurer que l'on a bien le même rayon en mettant d'abord le compas en <code>A</code>, pour prendre le même rayon, puis en déplaçant le compas au point <code>P</code>.</p>
                </div>

                <div>
                    <div class="graphie" data-update="construction">graph.compassVertex=circle(graph.p2,.08,{stroke:null,fill:GRAY}).toBack(),graph.compassCircumference=circle(graph.p2,eDist(graph.p1,graph.p2),{fill:null,stroke:GRAY,strokeWidth:1,strokeDasharray:"- "})</div>
                    <p>Pour déterminer la distance entre les <span class="hint_blue">deux points équidistants de <code>A</code></span> on peut utiliser un compas que l'on centre sur un point, puis modifier l'écartement de manière à relier le second point.</p>
                </div>

                <div>
                    <div class="graphie" data-update="construction">graph.compassVertex.animate({cx:scalePoint(graph.p4)[0],cy:scalePoint(graph.p4)[1]},1e3),graph.compassCircumference.animate({cx:scalePoint(graph.p4)[0],cy:scalePoint(graph.p4)[1]},1e3)</div>
                    <p>Maintenant déplacez le compas à l'intersection du premier coup de compas avec la droite passant par <code>P</code>.</p>
                </div>

                <div>
                    <div class="graphie" data-update="construction">drawHintLine(graph.p1,graph.p2,1),drawHintLine(graph.p3,graph.p4,1),drawHintLine(P,graph.p3,2),drawHintLine(P,graph.p4,2),circle(graph.p3,.08,{stroke:null,fill:BLUE}),circle(graph.p4,.08,{stroke:null,fill:BLUE})</div>
                    <p>On peut maintenant utiliser le point d'intersection des deux cercles pour construire un triangle dont les côtés auront la même longueur que le triangle ayant pour sommet le point <code>A</code>.</p>
                </div>

                <div>
                    <div class="graphie" data-update="construction">var dx=10*cos(ROT),dy=10*sin(ROT);line([P[0]+dx,P[1]+dy],[P[0]-dx,P[1]-dy],{strokeWidth:1,stroke:BLUE}).toBack()</div>
                    <p>Finalement, utilisez une règle pour relier le point <code>P</code> aux intersections des deux coups de compas. Cette droite doit être parallèle à la première droite.</p>
                </div>
            </div>
        </div>

        <div id="bisector">
            <div class="problem">
                <form>
                    <input onclick="javascript: KhanUtil.construction.addCompass();" type="button" value="Utiliser un compas"><input onclick="javascript: KhanUtil.construction.addStraightedge();" type="button" value="Tracer une droite"><input onclick="javascript: KhanUtil.construction.removeAllTools();" type="button" value="effacer">
</form>
                <p class="question">Construire la médiatrice du segment <code>\overline{AB}</code>.</p>
                <div class="graphie" id="construction">init({range:[[-5,5],[-5,5]],scale:50}),addMouseLayer(),addConstruction("construction");var a=applyRefFrame([1.5,0],ROT),b=applyRefFrame([-1.5,0],ROT);a=[roundToNearest(.01,a[0]),roundToNearest(.01,a[1])],b=[roundToNearest(.01,b[0]),roundToNearest(.01,b[1])],addDummyStraightedge(a,b,!1),addDummyPoint(a),addDummyPoint(b);var offset="above";180*ROT/PI&gt;50&amp;&amp;90&gt;180*ROT/PI&amp;&amp;(offset="left"),130&gt;180*ROT/PI&amp;&amp;180*ROT/PI&gt;90&amp;&amp;(offset="right"),label(a,"A",offset),label(b,"B",offset)</div>
            </div>
            <div class="solution" data-type="custom">
                <div class="instruction">Utiliser la règle et le compas pour tracer la médiatrice de <code>\overline{AB}</code>.</div>
                <div class="guess">getToolProperties(construction)</div>
                <div class="validator-function">return 0===guess.length?"":(perp=null,_.each(guess,function(e){null!=e.first&amp;&amp;(ang=atan2(e.second.coord[1]-e.first.coord[1],e.second.coord[0]-e.first.coord[0]),deg=180*ang/PI,origDeg=180*ROT/PI,(abs(deg-origDeg+90)%360&lt;7||abs(deg-origDeg-90)%360&lt;7)&amp;&amp;(perp=e))}),null==perp?!1:(comps=_.filter(guess,function(e){return null!=e.center}),comps.length&lt;2?!1:(onLine=[],_.each(comps,function(e){_.each(comps,function(r){thisSlope=(e.center.coord[1]-r.center.coord[1])/(e.center.coord[0]-r.center.coord[0]),thisYInt=e.center.coord[1]-thisSlope*e.center.coord[0],abs(thisSlope-SLOPE)&lt;.5&amp;&amp;abs(thisYInt)&lt;.1&amp;&amp;abs(e.radius-r.radius)&lt;.1&amp;&amp;(onLine=[e,r])})}),onLine.length&lt;2?!1:(interYInt=0,perpYInt=perp.first.coord[1]+perp.first.coord[0]*(1/SLOPE),abs(interYInt-perpYInt)&lt;.5))))</div>
                <div class="show-guess">showConstructionGuess(guess)</div>
            </div>
            <div class="hints">
                <div>
                    <div class="graphie" data-update="construction">graph.perp=raphael.set(),graph.perp.push(line(applyRefFrame([0,10],ROT),applyRefFrame([0,-10],ROT),{strokeWidth:1,stroke:BLUE})).toBack()</div>
                    <p>On peut juste tracer une droite et <em>essayer</em> de la dessiner juste, mais alors <strong>on n'a pas de garantie</strong> que ce soit dans les faits parfaitement perpendiculaire ou que ça coupe le segment exactement en son milieu.</p>
                    <p>Comment peut-on affirmer qu'une droite est bien une médiatrice ?</p>
                </div>
                <div>
                    <div class="graphie" data-update="construction">graph.hintLines=raphael.set(),style({fill:BLUE,stroke:null},function(){graph.perpPoint1=circle(applyRefFrame([0,-1],ROT),.08),graph.perpPoint2=circle(applyRefFrame([0,1],ROT),.08)}),graph.perp.push(drawHintLine(applyRefFrame([0,0],ROT),applyRefFrame([0,1],ROT),1)),graph.perp.push(drawHintLine(applyRefFrame([0,0],ROT),applyRefFrame([0,-1],ROT),1)),graph.hintLines.push(drawHintLine(applyRefFrame([0,-1],ROT),applyRefFrame([1.5,0],ROT),2)),graph.hintLines.push(drawHintLine(applyRefFrame([0,1],ROT),applyRefFrame([1.5,0],ROT),2)),graph.hintLines.push(drawHintLine(applyRefFrame([0,-1],ROT),applyRefFrame([-1.5,0],ROT),2)),graph.hintLines.push(drawHintLine(applyRefFrame([0,1],ROT),applyRefFrame([-1.5,0],ROT),2)),graph.perp.toBack(),graph.hintLines.toBack(),graph.perpPoint1.toBack(),graph.perpPoint2.toBack()</div>
                    <p>Si on choisit <span class="hint_blue">deux points</span> sur la médiatrice qui sont équidistants de l'intersection, alors ils seront aussi à équidistance de tout des deux points à partir desquels on a tracé le segment.</p>
                </div>
                <div>
                    <div class="graphie" data-update="construction">graph.perp.remove()</div>
                    <p>Si on n'a pas encore tracé de médiatrices, existe-t-il un autre moyen de trouver les points bleus ?</p>
                </div>
                <div>
                    <div class="graphie" data-update="construction">circle(applyRefFrame([1.5,0],ROT),.08,{fill:GRAY,stroke:null}),graph.compass1=circle(applyRefFrame([1.5,0],ROT),eDist(applyRefFrame([0,-1],ROT),applyRefFrame([1.5,0],ROT)),{stroke:GRAY,strokeWidth:1,fill:"none",strokeDasharray:"- "}).toBack()</div>
                    <p>Si on utilise un compas pour tracer un cercle de centre <code>A</code>, le cercle sera formé de tous les points situés à égale distance de <code>A</code>, notamment les deux points bleus.</p>
                </div>
                <div>
                    <div class="graphie" data-update="construction">circle(applyRefFrame([-1.5,0],ROT),.08,{fill:GRAY,stroke:null}),graph.compass2=circle(applyRefFrame([-1.5,0],ROT),eDist(applyRefFrame([0,-1],ROT),applyRefFrame([-2,0],ROT)),{stroke:GRAY,strokeWidth:1,fill:"none",strokeDasharray:"- "}).toBack()</div>
                    <p>On peut tracer un deuxième cercle centré en <code>B</code> qui coupe le premier cercle.</p>
                </div>
                <div>
                    <div class="graphie" data-update="construction">graph.hintLines.remove()</div>
                    <p>Mais attendez ! On peut utiliser ces cercles pour tracer une droite perpendiculaire, <strong>mais pas une bissectrice ! </strong> C'est pourquoi les deux cercles sont de de tailles différentes.</p>
                </div>
                <div>
                    <div class="graphie" data-update="construction">graph.compass1.animate({rx:scaleVector(3)[0],ry:scaleVector(3)[1]},250),graph.compass2.animate({rx:scaleVector(3)[0],ry:scaleVector(3)[1]},250),graph.perpPoint1.animate({cx:scalePoint(applyRefFrame([0,-1.5*sqrt(3)],ROT))[0],cy:scalePoint(applyRefFrame([0,-1.5*sqrt(3)],ROT))[1]},250),graph.perpPoint2.animate({cx:scalePoint(applyRefFrame([0,1.5*sqrt(3)],ROT))[0],cy:scalePoint(applyRefFrame([0,1.5*sqrt(3)],ROT))[1]},250)</div>
                    <p>Une bonne méthode pour faire des cercles de a même taille est de mettre les rayons égaux à la distance entre <code>A</code> et <code>B</code>. Vous pouvez le faire en mettant le centre en un point et le crayon du compas à un autre. </p>
                </div>
                <div>
                    <div class="graphie" data-update="construction">graph.perpPoint1.attr({fill:GRAY}),graph.perpPoint2.attr({fill:GRAY}),line(applyRefFrame([0,10],ROT),applyRefFrame([0,-10],ROT),{strokeWidth:1,stroke:GRAY,strokeDasharray:"- "}).toBack()</div>
                    <p>Utiliser une règle pour relier les deux point où les cercles se croisent. Cette droite est la médiatrice de <code>\overline{AB}</code>.</p>
                </div>
            </div>
        </div>

        <div id="angle-bisect">
            <div class="vars" data-apply="replace">
                <var id="ROT">randRange(30, 80) * PI / 180</var>
                <var id="CENTER">[randRange(-3, 0), 0]</var>
                <var id="HGRAPH">1</var>
                <var id="A">CENTER</var>
                <var id="B">[CENTER[0] + 4, CENTER[1]]</var>
                <var id="C">function(){var e=applyRefFrame([4,0],ROT);return e=[e[0]+CENTER[0],e[1]+CENTER[1]],e=[roundToNearest(.01,e[0]),roundToNearest(.01,e[1])]}()</var>
            </div>
            <div class="problem">
                <form>
                    <input onclick="javascript: KhanUtil.construction.addCompass();" type="button" value="Utiliser un compas"><input onclick="javascript: KhanUtil.construction.addStraightedge();" type="button" value="Tracer une droite"><input onclick="javascript: KhanUtil.construction.removeAllTools();" type="button" value="effacer">
</form>
                <p class="question">Construire la bissectrice de l'angle représenté.</p>
                <div class="graphie" id="construction">init({range:[[-5,5],[-2,5]],scale:50}),addMouseLayer(),addConstruction("construction"),addDummyRay(A,B),addDummyRay(A,C)</div>
            </div>
            <div class="solution" data-type="custom">
                <div class="instruction">Utiliser la règle et le compas pour tracer la bissectrice d'un angle.</div>
                <div class="guess">getToolProperties(construction)</div>
                <div class="validator-function">if(0===guess.length)return"";var e=null;if(_.each(guess,function(r){null!=r.first&amp;&amp;(ang=atan2(r.second.coord[1]-r.first.coord[1],r.second.coord[0]-r.first.coord[0]),ang=0&gt;ang?ang+PI:ang,abs(ROT/2-ang)&lt;3*PI/180&amp;&amp;(e=r))}),null==e)return!1;var r=null,a=null,t=null,n=_.filter(guess,function(e){return null!=e.center});if(n.length&lt;3)return!1;if(_.each(n,function(e){eDist(e.center.coord,CENTER)&lt;.5&amp;&amp;(r=e)}),null==r)return!1;var s=[];_.each(n,function(e){s=[CENTER[0]+r.radius,CENTER[1]],eDist(e.center.coord,s)&lt;.5&amp;&amp;(a=e)});var i=[];return _.each(n,function(e){i=[CENTER[0]+applyRefFrame([r.radius,0],ROT)[0],CENTER[1]+applyRefFrame([r.radius,0],ROT)[1]],eDist(e.center.coord,i)&lt;.5&amp;&amp;(t=e)}),null==a||null==t?!1:abs(a.radius-t.radius)&lt;.5</div>
                <div class="show-guess">showConstructionGuess(guess)</div>
            </div>
            <div class="hints">
                <div>
                    <div class="graphie" data-update="construction">var farPoint=[applyRefFrame([10,0],ROT/2)[0]+CENTER[0],applyRefFrame([10,0],ROT/2)[1]+CENTER[1]];graph.bisect=line(CENTER,farPoint,{stroke:BLUE,strokeWidth:1}),graph.bisect.toBack()</div>
                    <p>On pourrait simplement tracer une droite et <em>essayer</em> d'en faire une bissectrice, mais c'est difficile à faire et <strong>on ne peut pas garantir</strong> que ce soit une bissectrice parfaite.</p>
                </div>
                <div>
                    <div class="graphie" data-update="construction">graph.hintLines=raphael.set(),graph.intersect1=[CENTER[0]+2,CENTER[1]],graph.intersect2=[applyRefFrame([2,0],ROT)[0]+CENTER[0],applyRefFrame([2,0],ROT)[1]+CENTER[1]],circle(graph.intersect1,.08,{stroke:null,fill:BLUE}),circle(graph.intersect2,.08,{stroke:null,fill:BLUE}),graph.hintLines.push(drawHintLine(CENTER,graph.intersect1,1)),graph.hintLines.push(drawHintLine(CENTER,graph.intersect2,1)),graph.hintLines.push(drawHintLine(graph.intersect1,[applyRefFrame([2.5,0],ROT/2)[0]+CENTER[0],applyRefFrame([2.5,0],ROT/2)[1]+CENTER[1]],2)),graph.hintLines.push(drawHintLine(graph.intersect2,[applyRefFrame([2.5,0],ROT/2)[0]+CENTER[0],applyRefFrame([2.5,0],ROT/2)[1]+CENTER[1]],2)),graph.hintLines.push(drawHintLine(graph.intersect1,[applyRefFrame([4,0],ROT/2)[0]+CENTER[0],applyRefFrame([4,0],ROT/2)[1]+CENTER[1]],3)),graph.hintLines.push(drawHintLine(graph.intersect2,[applyRefFrame([4,0],ROT/2)[0]+CENTER[0],applyRefFrame([4,0],ROT/2)[1]+CENTER[1]],3)),graph.hintLines.toBack()</div>
                    <p>Si on choisit <span class="hint_blue">deux points au hasard sur les droites existantes</span> situés à équidistance du sommet de l'angle, alors tout point situé sur la bissectrice de cet angle sera équidistant de ces deux points.</p>
                </div>
                <div>
                    <div class="graphie" data-update="construction">circle(CENTER,.08,{stroke:null,fill:GRAY}),circle(CENTER,2,{fill:null,stroke:GRAY,strokeWidth:1,strokeDasharray:"- "})</div>
                    <p>On peut tracer un cercle centré sur le sommet pour trouver <span class="hint_blue">deux points équidistants du sommet</span>.</p>
                </div>
                <div>
                    <div class="graphie" data-update="construction">graph.bisect.remove(),circle(graph.intersect1,.08,{stroke:null,fill:GRAY}),graph.compass1=circle(graph.intersect1,1.5,{fill:null,stroke:GRAY,strokeWidth:1,strokeDasharray:"- "}),circle(graph.intersect2,.08,{stroke:null,fill:GRAY}),graph.compass2=circle(graph.intersect2,1.8,{fill:null,stroke:GRAY,strokeWidth:1,strokeDasharray:"- "}),graph.hintLines.remove()</div>
                    <p>Si on utilise le compas pour tracer deux cercles supplémentaires centré sur chacun des <span class="hint_blue">deux points</span>, on observe qu'ils s'entrecoupent, <strong>mais pas sur la bissectrice !</strong> C'est parceque les deux cercles n'ont pas le même rayon.</p>
                </div>
                <div>
                    <div class="graphie" data-update="construction">graph.compass1.animate({rx:scaleVector(2)[0],ry:scaleVector(2)[1]},250),graph.compass2.animate({rx:scaleVector(2)[0],ry:scaleVector(2)[1]},250)</div>
                    <p>Un bon moyen de tracer des cercles de même taille est de placer leurs bords de telle façon qu'ils passent à travers le sommet.</p>
                </div>
                <div>
                    <div class="graphie" data-update="construction">circle([CENTER[0]+2+2*cos(ROT),CENTER[1]+2*sin(ROT)],.08,{stroke:null,fill:GRAY}),line([applyRefFrame([-10,0],ROT/2)[0]+CENTER[0],applyRefFrame([-10,0],ROT/2)[1]+CENTER[1]],[applyRefFrame([10,0],ROT/2)[0]+CENTER[0],applyRefFrame([10,0],ROT/2)[1]+CENTER[1]],{stroke:GRAY,strokeWidth:1,strokeDasharray:"- "})</div>
                    <p>Utiliser une règle pour relier le sommet au point où se rencontre les deux derniers cercles tracés. Cette droite est la bissectrice de l'angle.</p>
                </div>
            </div>
        </div>

        <div id="copy-segment">
            <div class="vars">
                <var id="LENGTH">randRange(3, 6) / 2</var>
                <var id="DY">randRange(2, 4) / 2</var>
                <var id="A">applyRefFrame([LENGTH / 2, -DY], ROT)</var>
                <var id="B">applyRefFrame([-LENGTH / 2, -DY], ROT)</var>
                <var id="P">applyRefFrame([0, DY], ROT)</var>
            </div>

            <div class="problem">
                <form>
                    <input onclick="javascript: KhanUtil.construction.addCompass();" type="button" value="Utiliser un compas"><input onclick="javascript: KhanUtil.construction.addStraightedge(false);" type="button" value="Tracer une droite"><input onclick="javascript: KhanUtil.construction.removeAllTools();" type="button" value="effacer">
</form>
                <p class="question">Construisez un segment de la même longueur que <code>\overline{AB}</code>, avec une des extrémités en <code>P</code>.</p>
                <div class="graphie" id="construction">init({range:[[-5,5],[-5,5]],scale:50}),addMouseLayer(),addConstruction("construction"),addDummyStraightedge(A,B,!1),addDummyPoint(A),addDummyPoint(B),addDummyPoint(P);var label_position=abs(SLOPE)&gt;1.5?"left":"below";label(A,"A",label_position),label(B,"B",label_position),label(P,"P","below")</div>
            </div>

            <div class="solution" data-type="custom">
                <div class="instruction">Utilisez le compas et la règle pour construire un segment de la même longueur que <code>\overline{AB}</code>.</div>
                <div class="guess">getToolProperties(construction)</div>
                <div class="validator-function">if(0===guess.length)return"";var e=_.any(guess,function(e){return null!=e.first&amp;&amp;(eDist(e.first.coord,P)&lt;.5||eDist(e.second.coord,P)&lt;.5)&amp;&amp;abs(eDist(e.first.coord,e.second.coord)-LENGTH)&lt;.5});if(!e)return!1;var r=findCompass(guess,{cx:P[0],cy:P[1],radius:LENGTH});return 1===r.length</div>
                <div class="show-guess">showConstructionGuess(guess)</div>
            </div>

            <div class="hints">
                <div>
                    <div class="graphie" data-update="construction">graph.p1=[P[0]+LENGTH*cos(ROT),P[1]+LENGTH*sin(ROT)],graph.segment=line(P,graph.p1,{strokeWidth:1,stroke:BLUE,extend:!1}).toBack(),graph.lineEnd=circle(graph.p1,.08,{stroke:null,fill:BLUE})</div>
                    <p>On pourrait juste tracer un segment passant par <code>P</code> et <em>essayer</em> de lui donner la même longueur que <code>\overline{AB}</code>, mais alors <strong>on n'a aucune garantie</strong> que ce soit exactement la même.</p>
                    <p>Comment pourrait-on trouver tous les points à la bonne distance de <code>P</code> ?</p>
                </div>

                <div>
                    <div class="graphie" data-update="construction">graph.segment.remove(),graph.lineEnd.remove(),graph.compassVertex=circle(A,.08,{stroke:null,fill:GRAY}),graph.compassCircumference=circle(A,LENGTH,{fill:null,stroke:GRAY,strokeWidth:1,strokeDasharray:"- "})</div>
                    <p>Si on centre un compas en<code>A</code> et que l'on prend son rayon tel qu'il croise <code>A</code>, alors on aura un compas avec un rayon de la longueur correcte.</p>
                </div>

                <div>
                    <div class="graphie" data-update="construction">graph.compassVertex.animate({cx:scalePoint(P)[0],cy:scalePoint(P)[1]},1e3),graph.compassCircumference.animate({cx:scalePoint(P)[0],cy:scalePoint(P)[1]},1e3)</div>
                    <p>On peut maintenant déplacer le compas sur le point <code>P</code>.</p>
                </div>


                <div>
                    <div class="graphie" data-update="construction">graph.segment=line(P,graph.p1,{strokeWidth:1,stroke:BLUE,extend:!1}).toBack(),graph.lineEnd=circle(graph.p1,.08,{stroke:null,fill:BLUE})</div>
                    <p>Finalement, utilisez une règle pour relier le point <code>P</code> à n'importe quel point du cercle au compas.</p>
                </div>
            </div>
        </div>

        <div id="copy-angle">
            <div class="vars" data-apply="replace">
                <var id="ROT">randRange(30, 80) * PI / 180</var>
                <var id="CENTER">[randFromArray([-2, 2]), 0]</var>
                <var id="HGRAPH">1</var>
                <var id="A">[CENTER[0] - 1.5, CENTER[1]]</var>
                <var id="B">[CENTER[0] + 1.5, CENTER[1]]</var>
                <var id="C">function(){var e=applyRefFrame([3,0],ROT);return e=[e[0]+A[0],e[1]+CENTER[1]],e=[roundToNearest(.01,e[0]),roundToNearest(.01,e[1])]}()</var>
                <var id="P">[-CENTER[0] - 1, 2.5]</var>
            </div>
            <div class="problem">
                <form>
                    <input onclick="javascript: KhanUtil.construction.addCompass();" type="button" value="Utiliser un compas"><input onclick="javascript: KhanUtil.construction.addStraightedge(false);" type="button" value="Tracer une droite"><input onclick="javascript: KhanUtil.construction.removeAllTools();" type="button" value="effacer">
</form>
                <p class="question">Construire un angle de sommet <code>P</code> égal à <code>\angle BAC</code>.</p>
                <div class="graphie" id="construction">init({range:[[-5,5],[-2,5]],scale:50}),addMouseLayer(),addConstruction("construction"),addDummyRay(A,B),addDummyRay(A,C),addDummyPoint(P),label(A,"A","below"),label(B,"B","below"),label(C,"C","above"),label(P,"P","below")</div>
            </div>
            <div class="solution" data-type="custom">
                <div class="instruction">Construire à la règle et au compas un angle de sommet <code>P</code> égal à <code>\angle BAC</code>.</div>
                <div class="guess">getToolProperties(construction)</div>
                <div class="validator-function">if(0===guess.length)return"";var e=_.filter(guess,function(e){return null!=e.first&amp;&amp;(eDist(e.first.coord,P)&lt;.5||eDist(e.second.coord,P)&lt;.5)});if(2!==e.length)return!1;var r=_.map(e,function(e){var r,a;return eDist(e.first.coord,P)&lt;.5?(r=e.first.coord,a=e.second.coord):(r=e.second.coord,a=e.first.coord),atan2(r[1]-a[1],r[0]-a[0])}),a=180*r[0]/PI,t=180*r[1]/PI;a+=0&gt;a?180:0,t+=0&gt;t?180:0;var n=min(180-abs(a-t),abs(a-t));if(abs(n-180*ROT/PI)&gt;3)return!1;var s=findCompass(guess,{cx:P[0],cy:P[1]});if(1!==s.length)return!1;var i=s[0].radius,o=[P[0]-i*cos(r[0]),P[1]-i*sin(r[0])],l=[P[0]-i*cos(r[1]),P[1]-i*sin(r[1])],c=(PI-ROT)/2,p=2*i*cos(c),h=findCompass(guess,{cx:o[0],cy:o[1],radius:p}),g=findCompass(guess,{cx:l[0],cy:l[1],radius:p});return 1===h.length||1===g.length</div>
                <div class="show-guess">showConstructionGuess(guess)</div>
            </div>
            <div class="hints">
                <div>
                    <div class="graphie" data-update="construction">line(P,[P[0]+2.5,P[1]],{strokeWidth:1,stroke:BLUE}).toBack(),circle([P[0]+2.5,P[1]],.08,{stroke:null,fill:BLUE})</div>
                    <p>D'abord, on doit tracer une droite passant par <code>P</code>.</p>
                </div>

                <div>
                    <div class="graphie" data-update="construction">graph.p4=[applyRefFrame([2,0],ROT)[0]+P[0],applyRefFrame([2,0],ROT)[1]+P[1]],graph.hintLines=raphael.set(),graph.hintLines.push(line(P,graph.p4,{strokeWidth:1,stroke:BLUE})).toBack(),graph.hintPoint=circle(graph.p4,.08,{stroke:null,fill:BLUE})</div>
                    <p>On pourrait simplement tracer une deuxième droite passant par <code>P</code> en <em>essayant</em> d'obtenir un angle identique à <code>\angle BAC</code>, mais c'est difficile à faire et <strong>rien ne garantit</strong> que l'angle sera exactement le même.</p>
                </div>

                <div>
                    <div class="graphie" data-update="construction">graph.p1=[A[0]+2,A[1]],graph.p2=[applyRefFrame([2,0],ROT)[0]+A[0],applyRefFrame([2,0],ROT)[1]+A[1]],graph.p3=[P[0]+2,P[1]],circle(graph.p1,.08,{stroke:null,fill:BLUE}),circle(graph.p2,.08,{stroke:null,fill:BLUE}),drawHintLine(A,graph.p1,2).toBack(),drawHintLine(A,graph.p2,2).toBack(),graph.hintLines.push(drawHintLine(graph.p1,graph.p2,1)),graph.hintLines.push(drawHintLine(graph.p3,graph.p4,1)),graph.hintLines.push(drawHintLine(P,graph.p3,2)),graph.hintLines.push(drawHintLine(P,graph.p4,2)),graph.hintLines.toBack()</div>
                    <p>Si on construit  <span class="hint_blue">un triangle</span> dont un sommet correspond au point <code>A</code>, puis on construit un triangle avec des côtés de même longueurs et sont un sommet est le point <code>P</code>, alors les angles en <code>A</code> et en <code>P</code> seront identiques.</p>
                </div>

                <div>
                    <div class="graphie" data-update="construction">graph.hintLines.remove(),graph.hintPoint.remove(),circle(A,.08,{stroke:null,fill:GRAY}),circle(A,2,{fill:null,stroke:GRAY,strokeWidth:1,strokeDasharray:"- "})</div>
                    <p>On peut utiliser un compas centré en <code>A</code> pour trouver<span class="hint_blue">deux points équidistants de <code>A</code></span>.</p>
                </div>

                <div>
                    <div class="graphie" data-update="construction">var compassVertex=circle(A,.08,{stroke:null,fill:GRAY}),compassCircumference=circle(A,2,{fill:null,stroke:GRAY,strokeWidth:1,strokeDasharray:"- "});compassVertex.animate({cx:scalePoint(P)[0],cy:scalePoint(P)[1]},1e3),compassCircumference.animate({cx:scalePoint(P)[0],cy:scalePoint(P)[1]},1e3),circle(graph.p3,.08,{stroke:null,fill:BLUE}),drawHintLine(P,graph.p3,2)</div>
                    <p>On peut utiliser un compas <strong>avec le même rayon</strong> centré en <code>P</code> pour trouver tous les points à la même distance de <code>P</code>. On peut s'assurer que l'on a bien le même rayon en mettant d'abord le compas en <code>A</code>, pour prendre le même rayon, puis en déplaçant le compas au point <code>P</code>.</p>
                </div>

                <div>
                    <div class="graphie" data-update="construction">graph.compassVertex=circle(graph.p1,.08,{stroke:null,fill:GRAY}),graph.compassCircumference=circle(graph.p1,eDist(graph.p1,graph.p2),{fill:null,stroke:GRAY,strokeWidth:1,strokeDasharray:"- "})</div>
                    <p>Pour déterminer la distance entre les <span class="hint_blue">deux points équidistants de <code>A</code></span> on peut utiliser un compas que l'on centre sur un point, puis modifier l'écartement de manière à relier le second point.</p>
                </div>

                <div>
                    <div class="graphie" data-update="construction">graph.compassVertex.animate({cx:scalePoint(graph.p3)[0],cy:scalePoint(graph.p3)[1]},1e3),graph.compassCircumference.animate({cx:scalePoint(graph.p3)[0],cy:scalePoint(graph.p3)[1]},1e3)</div>
                    <p>Maintenant déplacez le compas à l'intersection du premier coup de compas avec la droite passant par <code>P</code>.</p>
                </div>

                <div>
                    <div class="graphie" data-update="construction">var dx=10*cos(ROT),dy=10*sin(ROT);drawHintLine(P,graph.p4,2),drawHintLine(graph.p3,graph.p4,1),line(P,graph.p4,{strokeWidth:1,stroke:BLUE}).toBack(),line(P,graph.p4,{strokeWidth:1,stroke:BLUE}).toBack(),circle(graph.p4,.08,{stroke:null,fill:BLUE})</div>
                    <p>
                        Finally use a straightedge to connect point <code>P</code> to where the two compasses intersect.
                        The angle formed at point <code>P</code> will be the same as <code>\angle BAC</code>.
                    </p>
                </div>
            </div>
        </div>
    </div>
    </div>
</body>
</html>
